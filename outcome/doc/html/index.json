[
{
	"uri": "https://ned14.github.io/outcome/requirements/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Outcome is a header only C++ 14 library known to work on these compiler-platform combinations or better:\n clang 4.0.1 (LLVM) [FreeBSD, Linux, OS X] GCC 6.3 [Linux] Visual Studio 2017 [Windows] XCode 9 [MacOS]  It is worth turning on C++ 17 if you can, as there are many usability and performance improvements. If your compiler implements the Concepts TS, it is worth turning support on. Support is automatically detected and used.\nPartially working compilers:\n GCC 5.4.1 is highly usable so long as you don\u0026rsquo;t use Outcome in a constexpr evaluation context. clang 3.5 - 3.9 can compile varying degrees of the test suite, the problem is lack of complete and unbuggy C++ 14 language support.  "
},
{
	"uri": "https://ned14.github.io/outcome/build/",
	"title": "Build and install",
	"tags": [],
	"description": "",
	"content": " Outcome v2 is feature complete, meeting the feedback from the Boost peer review in May 2017. It is an all new code base, written entirely from scratch during the month of June 2017. It has completed three months of maturation, and will shortly be sent back to Boost for a second peer review. As a result, consider this library to beta quality and subject change if a second review demands it.\nThat said, the essentials here are the same as they were in v1. Indeed most code written for v1 should be convertible to v2 without too much effort.\nUsage as a single header file Outcome v2 comes in single header file form. This is regenerated per commit. To fetch on Linux:\nwget https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  On BSD and OS X:\nfetch https://github.com/ned14/outcome/raw/develop/single-header/outcome.hpp  On Windows, simply download the raw file from above and place it wherever it suits you.\nUsage from the Conan package manager (thanks to Th√©o Delrieu for contributing this support)\nAt the command line, add the bintray repo for Outcome to conan:\nconan remote add outcome https://api.bintray.com/conan/ned14/Outcome  Now simply add this to your Conan build:\n[requires] Outcome/master@ned14/stable  Outcome will be made available by Conan at \u0026lt;outcome.hpp\u0026gt;.\nUsage as a git submodule Given that v2 is still under development, it is currently best used as a git submodule to your project so you can keep abreast of bug fixes. Here is how:\ngit submodule add https://github.com/ned14/outcome cd outcome git checkout develop git submodule update --init --recursive  After this you can bring Outcome into your code using:\n#include \u0026quot;outcome/include/outcome.hpp\u0026quot;  That\u0026rsquo;s it, you are ready to go. From time to time, you may wish to update to latest:\ncd outcome git pull git submodule update  Usage as a stable source tarball If you would prefer a single source tarball of the stable branch containing all the documentation, tests and sources, this can always be retrieved from:\nhttps://dedi5.nedprod.com/static/files/outcome-v2.0-source-latest.tar.xz\nThis tarball is automatically generated when Outcome fully compiles and passes all unit tests on all platforms tested by the CIs. This currently includes:\n Linux: GCC 6.3, clang 4.0 MacOS: XCode 9 Windows: VS2017   Running the unit test suite To run the unit test suite you will need cmake 3.1 or later installed.\nmkdir build cd build cmake .. cmake --build . ctest  On some cmake generators (Visual Studio, Xcode) you may need to tell cmake build a configuration like Release or Debug. Similarly, ctest needs to be told the same e.g.\nmkdir build cd build cmake .. cmake --build . --config Release ctest -C Release  Per commit, tests are run by Travis and uploaded to a CDash dashboard here.\n Modular CMake build support If you are using Outcome in a CMake project, Outcome is a \u0026ldquo;modular cmake\u0026rdquo; project using only modern cmake 3 throughout. This lets you add the Outcome directory as a cmake subdirectory with no unexpected consequence on the rest of your cmake. You will need to be using cmake 3.1 or better.\nadd_subdirectory( \u0026quot;${CMAKE_CURRENT_SOURCE_DIR}/outcome\u0026quot; # path to outcome source \u0026quot;${CMAKE_CURRENT_BINARY_DIR}/outcome\u0026quot; # your choice of where to put binaries EXCLUDE_FROM_ALL # please only lazy build outcome on demand )  Outcome\u0026rsquo;s cmake has the following useful products:\n outcome::hl (target): the Outcome header only library. Add this to any target_link_libraries() in your cmake to bring in Outcome as a header only library. This will also add to your link (via PUBLIC) any debugger visualisation support files, any system library dependencies and also force all consuming executables to be configured with a minimum of C++ 14 as Outcome requires a minimum of that. outcome_TEST_TARGETS (list): a list of targets which generate Outcome\u0026rsquo;s test suite. You can append this to your own test suite if you wish to run Outcome\u0026rsquo;s test suite along with your own.  "
},
{
	"uri": "https://ned14.github.io/outcome/use-matrix/",
	"title": "Decision matrix",
	"tags": [],
	"description": "",
	"content": "To help you decide whether Outcome would be useful for your particular problem, the following decision matrix may be useful.\ngraph LR; FAILURE{Failure is regularly passed upthe stack to be handled?} FAILURE ==\"Yes\"== FREQUENT{Occasional failure is likely?} FREQUENT ==\"Yes\"== OUTCOME[Use Outcome] EXCEPTION[Use C++ exceptionthrows] FREQUENT --\"No\"-- EXCEPTION  graph LR; FIXED{Worst casebounded execution timesare important to you?} TABLE{Your compiler usestable-based EH?} OUTCOME[Use Outcome] EXCEPTION[Use C++ exceptionthrows] FIXED ==\"Yes\"== TABLE TABLE ==\"Yes\"== OUTCOME FIXED --\"No\"-- EXCEPTION TABLE --\"No\"-- EXCEPTION \ngraph TD; FAILURE{Failure handlinglogic is as important ormore important thansuccess handling logic?} COST{The cost of fullytesting your codefor exception safetyisn't worth it toyour organisation?} AUDIT{Code peer reviewchecks correctness offailure handling first?} EXCEPTIONS{You compile withC++ exceptionsglobally disabled?} SAFETY{You wish to startadding exceptionthrowing code intoan older codebasenot written to beexception safe?} OUTCOME[Use Outcome] EXCEPTION[Use C++ exceptionthrows] FAILURE ==\"Yes\"== OUTCOME AUDIT ==\"Yes\"== OUTCOME COST ==\"Yes\"== OUTCOME EXCEPTIONS ==\"Yes\"== OUTCOME SAFETY ==\"Yes\"== OUTCOME FAILURE --\"No\"-- EXCEPTION AUDIT --\"No\"-- EXCEPTION COST --\"No\"-- EXCEPTION EXCEPTIONS --\"No\"-- EXCEPTION SAFETY --\"No\"-- EXCEPTION \n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/problem/",
	"title": "Incommensurate E types",
	"tags": [],
	"description": "",
	"content": "Back in the tutorial section on Default Actions, we studied a likely very common initial choice of E type: a strongly typed enum. We saw how by marking up strongly typed enums to tell the C++ standard library what they are, they gain implicit convertibility into std::error_code, and we then pointed out that you might as well now set E = std::error_code as that comes with the enormous advantage that you can use the boilerplate saving OUTCOME_TRY macro when the E type is always the same.\nWe thus strongly recommend to users that for any given piece of code, always using the same E type across the codebase is very wise, except where you explicitly want to prevent implicit propagation of failure up a call stack e.g. local failures in some domain specific piece of code.\nHowever it is unreasonable to expect that any non-trivial codebase can make do with E = std::error_code. This is why Outcome allows you to use custom E types which carry payload in addition to an error code, yet still have the Default Actions of std::error_code, including lazy custom exception throw synthesis.\nAll this is good, but if library A uses result\u0026lt;T, libraryA::failure_info\u0026gt;, and library B uses result\u0026lt;T, libraryB::error_info\u0026gt; and so on, there becomes a problem for the application writer who is bringing in these third party dependencies and tying them together into an application. As a general rule, each third party library author will not have built in explicit interoperation support for unknown other third party libraries. The problem therefore lands with the application writer.\nThe application writer has one of three choices:\n In the application, the form of result used is result\u0026lt;T, std::variant\u0026lt;E1, E2, ...\u0026gt;\u0026gt; where E1, E2 \u0026hellip; are the failure types for every third party library in use in the application. This has the advantage of preserving the original information exactly, but comes with a certain amount of use inconvenience and maybe excessive coupling between high level layers and implementation detail.\n One can translate/map the third party\u0026rsquo;s failure type into the application\u0026rsquo;s failure type at the point of the failure exiting the third party library and entering the application. One might do this, say, with a C preprocessor macro wrapping every invocation of the third party API from the application. This approach may lose the original failure detail, or mis-map under certain circumstances if the mapping between the two systems is not one-one.\n One can type erase the third party\u0026rsquo;s failure type into some application failure type, which can later be reconstituted if necessary. This is the cleanest solution with the least coupling issues and no problems with mis-mapping, but it almost certainly requires the use of malloc which the previous two did not.\n  Things get even more complication in the presence of callbacks. If in the callback you supply to library A, you call library B, you may need to insert switch statement maps or other mechanisms to convert library B\u0026rsquo;s failures into something library A can understand, and then somehow extract that out \u0026ndash; preferably without loss of original information \u0026ndash; into the application\u0026rsquo;s failure handling mechanism if library A subsequently returns failure as well. This implies transmitting state by which to track these interrelated pieces of failure data.\nLet us see what Outcome can do to help the application writer address some of these issues, next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/udt-err/",
	"title": "User defined error types",
	"tags": [],
	"description": "",
	"content": "Let us imagine a some user defined value type (udt) and some user defined error type (err):\nstruct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; struct err { int a{0}; explicit err(int _a) : a(_a) { } err() = default; }; View this code on Github Firstly, note that both the udt and err types can be constructed from an int. Thus this won\u0026rsquo;t compile:\nresult\u0026lt;udt, err\u0026gt; res(5); // fails to compile, cannot convert \u0026#39;int\u0026#39; to result View this code on Github This is because all the implicit constructors self-disable because it could be ambiguous whether you might mean udt or err. This is not a problem, it just requires typing some more so you are explicit as to which you intend:\n// When it is not unambiguous which to construct, we must say which we want same as with std::variant\u0026lt;\u0026gt;  result\u0026lt;udt, err\u0026gt; res(in_place_type\u0026lt;err\u0026gt;, 5); View this code on Github Now, what do you think will happen if we try to retrieve a udt from this result holding an err?\nresult\u0026lt;udt, err\u0026gt; res(in_place_type\u0026lt;err\u0026gt;, 5); // What happens here? What exception type is thrown?  try { std::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl; } catch(const std::exception \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/value-or-error/",
	"title": "ValueOrError Concept",
	"tags": ["value-or-error"],
	"description": "",
	"content": " Something not really mentioned until now is how Outcome interoperates with the proposed std::expected\u0026lt;T, E\u0026gt;, whose design lands in between outcome::unchecked\u0026lt;T, E\u0026gt; and outcome::checked\u0026lt;T, E\u0026gt;, both of which are simplified aliases for outcome::result\u0026lt;T, E\u0026gt; hard coding the NoValuePolicy to a fixed policy.\nExpected and Outcome are isomorphic to one another in design intent, but interoperation for code using Expected and Outcome ought to be seamless thanks to the proposed ValueOrError concept framework, a subset of which Outcome implements.\nOutcome\u0026rsquo;s result\u0026lt;X, Y\u0026gt; will explicitly construct from any type matching the ValueOrError concept, which includes std::expected\u0026lt;A, B\u0026gt;, if A is constructible to X and B is constructible to Y. The ValueOrError concept in turn is true if and only if the input type has:\n A value_type and error_type member typedefs. A .has_value() observer returning a bool. .value() and .error() observers.  Implementation Outcome\u0026rsquo;s machinery for implementing ValueOrError conversion is user extensible by injection of specialisations of the value_or_error\u0026lt;DEST, SRC\u0026gt; type into the OUTCOME_V2_NAMESPACE::convert namespace.\nOutcome\u0026rsquo;s default convert::value_or_error\u0026lt;DEST, SRC\u0026gt; implementation explicitly excludes Outcome result and outcome types from the default mechanism as there is a major gotcha: Outcome\u0026rsquo;s .value() is often not callable in constexpr as it can throw, which makes this mechanism pretty much useless for constexpr code. Thus separate explicit converting constructors exist which constexpr convert from any Outcome type (though note that result construction from outcome does use the ValueOrError mechanism).\nExamples of how to implement your own convert::value_or_error\u0026lt;DEST, SRC\u0026gt; converter is demonstrated in the worked example, next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/happens1/",
	"title": "-- What happens?",
	"tags": ["undefined-behaviour"],
	"description": "",
	"content": "Let us run the code from the previous page:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_udts Segmentation fault (core dumped) ned@lyta:~/outcome/build_posix$  Apparently no exception was thrown? Correct. Nor was a value printed, though this will randomly vary depending on your compiler, libraries, the wind blowing on the day \u0026hellip;\nYou will probably find this surprising. This is because the default action for a user-defined error type is undefined behaviour1.\nLet us demonstrate this by recompiling the code to use the undefined behaviour sanitiser and see what happens instead:\nned@lyta:~/outcome/build_posix$ export UBSAN_OPTIONS=print_stacktrace=1 ned@lyta:~/outcome/build_posix$ bin/outcome-snippets_udts /home/ned/outcome/doc/src/snippets/../../../include/outcome/policy/detail/common.hpp:42:9: runtime error: execution reached a __builtin_unreachable() call #0 0x42a0dc in outcome_v2_1c2d524c::policy::detail::base::_ub() (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x42a0dc) #1 0x42a028 in void outcome_v2_1c2d524c::policy::detail::base::narrow_value_check\u0026lt;outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt; \u0026gt;(outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;*) (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x42a028) #2 0x429f0c in void outcome_v2_1c2d524c::policy::all_narrow::wide_value_check\u0026lt;outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt; \u0026gt;(outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;*) (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x429f0c) #3 0x4298d6 in outcome_v2_1c2d524c::detail::result_value_observers\u0026lt;outcome_v2_1c2d524c::detail::result_storage\u0026lt;main::udt, main::err, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;, main::udt, outcome_v2_1c2d524c::policy::all_narrow\u0026gt;::value() \u0026amp; (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x4298d6) #4 0x4295f1 in main (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x4295f1) #5 0x7f3bd59c1f44 in __libc_start_main /build/eglibc-SvCtMH/eglibc-2.19/csu/libc-start.c:287 #6 0x4030c3 in _start (/home/ned/outcome/build_posix/bin/outcome-snippets_udts+0x4030c3)  The undefined behaviour is correctly trapped at runtime by the undefined behaviour sanitiser.\n Note that this is hard undefined behaviour. The compiler (if GCC, clang, or MSVC) is explicitly told that observation of a value which is not present can never happen. The optimiser will thus generate code assuming it can never happen. This is what causes the segmentation fault above, no assembler is generated for the no-value observation case which causes corruption of the CPU registers, thus making visible early the undefined behaviour. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/all_narrow/",
	"title": "All narrow (hard UB)",
	"tags": [],
	"description": "",
	"content": " Header file all_narrow.hpp \n#include\u0026nbsp;\u0026quot;detail\u0026#x2F;common.hpp\u0026quot; namespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace\u0026nbsp;policy \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct all_narrow; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} }  \n\nStruct outcome_v2_xxx::policy::all_narrow \nstruct\u0026nbsp;all_narrow { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; };  Policy which treats wide checks as narrow checks.\nCan be used in both result and outcome.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::all_narrow::wide_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the value() functions. Calls narrow_value_check() and does nothing else.\nEffects: None.\nFunction outcome_v2_xxx::policy::all_narrow::wide_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the error() functions. Calls narrow_error_check() and does nothing else.\nEffects: None.\nFunction outcome_v2_xxx::policy::all_narrow::wide_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the exception() functions. Calls narrow_exception_check() and does nothing else.\nEffects: None.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/policies/anatomy/",
	"title": "Anatomy of a policy",
	"tags": [],
	"description": "",
	"content": "A NoValuePolicy is quite simple. This is a complete policy, only the top two thirds is needed if you never use the policy in an outcome.\nstruct blank_policy { //! Performs a narrow check of state, used in the assume_value() functions.  template \u0026lt;class Impl\u0026gt; static constexpr void narrow_value_check(Impl \u0026amp;\u0026amp;self) noexcept; //! Performs a narrow check of state, used in the assume_error() functions.  template \u0026lt;class Impl\u0026gt; static constexpr void narrow_error_check(Impl \u0026amp;\u0026amp;self) noexcept; //! Performs a wide check of state, used in the value() functions.  template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(Impl \u0026amp;\u0026amp;self); //! Performs a wide check of state, used in the error() functions.  template \u0026lt;class Impl\u0026gt; static constexpr void wide_error_check(Impl \u0026amp;\u0026amp;self); /******** These only used if the policy is used in Outcome ********/ //! Performs a narrow check of state, used in the assume_exception() functions.  template \u0026lt;class Impl\u0026gt; static constexpr void narrow_exception_check(Impl \u0026amp;\u0026amp;self) noexcept; //! Performs a wide check of state, used in the exception() functions.  template \u0026lt;class Impl\u0026gt; static constexpr void wide_exception_check(Impl \u0026amp;\u0026amp;self); }; View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/keeping_state/",
	"title": "Keeping state",
	"tags": ["backtrace"],
	"description": "",
	"content": "The first thing we are going to need is somewhere to store the stack backtrace. We could take the easier route and simply store it into an allocated block and keep the pointer as a custom payload in a result\u0026lt;T, std::pair\u0026lt;error_code, std::unique_ptr\u0026lt;stack_backtrace\u0026gt;\u0026gt;\u0026gt; (see previous section on Custom payloads). But let us assume that we care so deeply about bounded execution times that ever calling malloc is unacceptable.\nWe therefore are going to need some completely static and trivially typed storage perhaps kept per-thread to avoid the need to keep mutexes.\n/* Outcome\u0026#39;s hook mechanism works vis ADL, so we will need a custom namespace to ensure the hooks apply only to the types declared in this namespace only */ namespace error_code_extended { // The extra error information we will keep  struct extended_error_info { std::array\u0026lt;void *, 16\u0026gt; backtrace; // The backtrace  size_t items; // Items in backtrace array which are valid  }; struct mythreadlocaldata_t { // Keep 16 slots of extended error info as a ringbuffer  extended_error_info slots[16]; // The current oldest slot  uint16_t current{0}; // Return the oldest slot  extended_error_info \u0026amp;next() { return slots[(current++) % 16]; } // Retrieve a previously stored slot, detecting if it is stale  extended_error_info *get(uint16_t idx) { // If the idx is stale, return not found  if(idx - current \u0026gt;= 16) { return nullptr; } return slots + (idx % 16); } }; // Meyers\u0026#39; singleton returning a thread local data structure for this thread  inline mythreadlocaldata_t \u0026amp;mythreadlocaldata() { static thread_local mythreadlocaldata_t v; return v; } } View this code on Github The extended error info is kept in a sixteen item long ring buffer. We continuously increment the current index pointer which is a 16 bit value which will wrap after 65,535. This lets us detect an attempt to access recycled storage, and thus return item-not-found instead of the wrong extended error info.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/limitations/",
	"title": "Limitations",
	"tags": [],
	"description": "",
	"content": "C++ has excellent two-way compatibility with the C ABI, but there are some limitations you must observe to write C++ code which C code can call without marshalling at the ABI boundary:\n A C++ function may not throw exceptions if it is safe to call from C, and so should always be marked noexcept. A C++ function should be annotated with extern \u0026quot;C\u0026quot; to prevent its symbol being mangled, and thus give it the C rather than C++ ABI. You cannot use overloading in your extern \u0026quot;C\u0026quot; functions. You may only use types in your C++ function for which these traits are both true:  std::is_standard_layout_v\u0026lt;T\u0026gt; std::is_trivially_copyable_v\u0026lt;T\u0026gt; Note that std::is_trivially_copyable_v\u0026lt;T\u0026gt; also requires trivial destruction, but NOT trivial construction. This means that C++ can do non-trivial construction of otherwise trivial types.  Your C++ function should return either a result\u0026lt;T, E\u0026gt; or a result\u0026lt;T\u0026gt; i.e. with the EC defaulted to std::error_code or something with equal layout. Note that std::error_code has standard layout, and is trivially copyable, and thus is a legal type in C.  These type limitations might seem to be showstoppers to C++ programmers, but with a bit of care during library design, you can actually express a lot of complex C++ and still meet these requirements. For example, more than 80% of the APIs in my C++ 17 AFIO library (which I hope to propose in 2018 to become the File I/O TS for C++ 24) meets the above restrictions, and thus can be called directly from C code or any programming language which speaks the C ABI.\nA useful tip is to sprinkle static_assert() testing the two traits above around your header files for any types which can traverse the C ABI boundary, and add extern \u0026quot;C\u0026quot; free function thunks for your class member functions1. You should be ready to go from the C++ side at least.\n Or simply write a script to do this for you. A starter script can be found at https://github.com/ned14/afio/blob/master/scripts/make_free_functions.py. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/payload/copy_file/",
	"title": "The Filesystem TS",
	"tags": ["dual-api"],
	"description": "",
	"content": "Something which has long annoyed the purists in the C++ leadership is the problem of dual overloads in error_code capable standard library APIs.\nConsider the copy_file() API from the Filesystem TS:\nnamespace filesystem { /*! Copies the file at path `from` to path `to`. \\returns True if file was successfully copied. \\throws On failure throws `filesystem_error(ec.message(), from, to, ec)` with `ec` being the error code reported by the operating system. */ bool copy_file(const path \u0026amp;from, const path \u0026amp;to); /*! Copies the file at path `from` to path `to`. \\returns True if file was successfully copied. If false, `ec` is written with the error code reported by the operating system. \\throws Never throws. */ bool copy_file(const path \u0026amp;from, const path \u0026amp;to, std::error_code \u0026amp;ec) noexcept; } View this code on Github Before Outcome, the common design pattern was to provide throwing and non-throwing overloads of every API. As you can see above, the throwing API throws a filesystem::filesystem_error exception type which carries additional information, specifically two paths. These paths may refer to the files which were the source of any failure. However the non-throwing overload does not provide this additional information, which can make it more annoying to use the non-throwing overload sometimes.\nWhat if we could replace these two overloads of every API in the Filesystem TS with a single API, and additionally have the non-throwing edition return the exact same additional information as the throwing edition?\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/httplib/",
	"title": "The HTTP library",
	"tags": [],
	"description": "",
	"content": "Let us imagine a simple application: it fetches a HTTP page using a HTTP library, sends it through HTML tidy via the htmltidy library, and then writes it to disc using a filelib library. So three third party libraries, two using Outcome in incompatible ways, and the third being a C library just for kicks.\nLet us imagine that the HTTP library has the following public interface:\n// This is some standalone library implementing high level HTTP namespace httplib { // These are the error code that this HTTP library can return  enum class status_code { success = 0, // not the HTTP success code of 200  // A subset of all HTTP status codes for brevity  bad_request = 400, access_denied = 401, logon_failed = 402, forbidden = 403, not_found = 404, internal_error = 500 }; // This is the error type that this HTTP library can return  struct failure { status_code status{status_code::success}; std::string url{}; // The failing URL  }; // Localise a result implementation to this library  template \u0026lt;class T\u0026gt; using result = OUTCOME_V2_NAMESPACE::result\u0026lt;T, failure\u0026gt;; /* Performs a HTTP GET on the url, returning the body if successful, a failure with status_code if unsuccessful at the HTTP level, or a C++ exception throw if something catastrophic happened e.g. bad_alloc */ result\u0026lt;std::string\u0026gt; get(std::string url); } View this code on Github The HTTP library is a mixed-failure design. Likely failures (HTTP status codes) are returned via httplib::failure, unlikely failures (e.g. out of memory) are returned via throw of the usual STL exception types.\nThe sole API we bother describing is an implementation of HTTP GET. It fetches a URL, and either returns the contents or the failure reason why not.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/",
	"title": "Tutorial",
	"tags": [],
	"description": "",
	"content": "  result\u0026lt;T, EC\u0026gt; Gentle introduction to writing code with simple success-or-failure return types.\n Inspecting result\u0026lt;T, EC\u0026gt; TRY operations  outcome\u0026lt;T, EC, EP\u0026gt; Success-or-failure return types where failure can take two forms, expected/handled failure and unexpected/abort failure.\n Inspecting outcome\u0026lt;T, EC, EP\u0026gt;  Custom payloads Success-or-failure return types where extra information in addition to the error code accompanies failure.\n The Filesystem TS Upgrading the Filesystem TS Auto-throwing filesystem_error  Default actions The default rules for handling different categories of failure type\n User defined error types -- What happens? Error code enums -- What happens? -- Now what happens? error_code exception_ptr void unchecked\u0026lt;T, E\u0026gt; and checked\u0026lt;T, E\u0026gt;  Result returning constructors How to metaprogram construction of objects which use result\u0026lt;T, EC\u0026gt; to return failure instead of throwing a C\u0026#43;\u0026#43; exception.\n Two phase construction A file handle Phase 2 construction Phase 3 construct\u0026lt;T\u0026gt; Alternatives  Hooking events Intercepting useful events such as initial construction, copies and moves so you can capture backtraces, fire debug breakpoints etc.\n Keeping state ADL bridging Hook result Custom exception ptr Hook outcome  Policies Defining your own NoValuePolicy policies, plus an overview of the precanned policies which come in the Outcome source code.\n Anatomy of a policy Casting workaround Built-in policies  Using result\u0026lt;T\u0026gt; from C code Interacting with result\u0026lt;T, EC\u0026gt; returning C\u0026#43;\u0026#43; functions from C code.\n Limitations Example C\u0026#43;\u0026#43; function Calling it from C Variations  Interoperation Interoperating with std::expected\u0026lt;T, E\u0026gt; and other ValueOrError concept matching types.\n Incommensurate E types ValueOrError Concept The HTTP library The HTMLTidy library The File I/O library The Application Mapping the HTTP library into the Application 1/2 Mapping the HTTP library into the Application 2/2 Mapping the File I/O library into the Application Mapping the HTMLTidy library into the Application In use Conclusion  Custom error codes Illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes.\n   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/two-phase-init/",
	"title": "Two phase construction",
	"tags": [],
	"description": "",
	"content": "The first thing to do is to break your object\u0026rsquo;s construction into two phases:\n Place the object into a state where it can be legally destructed without doing any initialisation which could throw an exception (i.e. everything done in phase 1 is constexpr). This phase usually involves initialising member variables to various default values, most often using default member initialisers. Most standard C++ library objects and containers have constexpr constructors, and thus can be initialised during phase 1. If you need to initialise a member variable without a constexpr constructor, std::optional\u0026lt;T\u0026gt; is the usual workaround.\n Do the remainder of the construction, the parts which could fail. Because phase 1 placed the object into a legally destructible state, it is usually the case that one can bail out during phase 2 and the destructor will clean things up correctly.\n  The phase 1 construction will be placed into a private constexpr constructor so nobody external can call it. The phase 2 construction will be placed into a static member initialisation function which returns a result with either the successfully constructed object, or the cause of any failure to construct the object.\nFinally, as a phase 3, some simple metaprogramming will implement a construct\u0026lt;T\u0026gt;{Args...}() free function which will construct any object T by calling its static initialisation function with Args... and returning the result returned. This isn\u0026rsquo;t as nice as calling T(Args...) directly, but it\u0026rsquo;s not too bad in practice. And more importantly, it lets you write generic code which can construct any unknown object which fails via returning result, completely avoiding C++ exception throws.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/outcome/",
	"title": "outcome&lt;R, S, P&gt;",
	"tags": [],
	"description": "",
	"content": " Header file outcome.hpp \nnamespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using is_outcome\u0026nbsp;=\u0026nbsp;\u0026#x27;hidden\u0026#x27;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;is_outcome_v\u0026nbsp;=\u0026nbsp;detail::is_outcome\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace\u0026nbsp;hooks \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void hook_outcome_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void hook_outcome_copy_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void hook_outcome_move_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void hook_outcome_in_place_construction(T*, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;NoValuePolicy,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void override_outcome_exception(outcome\u0026lt;R, S, P, NoValuePolicy\u0026gt;*\u0026nbsp;o,\u0026nbsp;U\u0026amp;\u0026amp;\u0026nbsp;v)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class R,\u0026nbsp;class S,\u0026nbsp;class P,\u0026nbsp;class NoValuePolicy\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;class outcome; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(result\u0026lt;T, U, V\u0026gt;\u0026nbsp;const\u0026amp; a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026nbsp;const\u0026amp; b)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(result\u0026lt;T, U, V\u0026gt;\u0026nbsp;const\u0026amp; a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026nbsp;const\u0026amp; b)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;void swap(outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp;\u0026nbsp;a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp;\u0026nbsp;b)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace\u0026nbsp;hooks \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;NoValuePolicy,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void override_outcome_exception(outcome\u0026lt;R, S, P, NoValuePolicy\u0026gt;* o,\u0026nbsp;U\u0026amp;\u0026amp; v)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} }  \nAlias template outcome_v2_xxx::is_outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; using\u0026nbsp;is_outcome\u0026nbsp;=\u0026nbsp;\u0026#x27;hidden\u0026#x27;;  True if an outcome\nUnexposed entity outcome_v2_xxx::is_outcome_v \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;is_outcome_v\u0026nbsp;=\u0026nbsp;detail::is_outcome\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;::value;  True if an outcome\n\nFunction outcome_v2_xxx::hooks::hook_outcome_construction \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;hook_outcome_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept;  The default instantiation hook implementation called when a outcome is first created by conversion from one of its possible types. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters   \u0026mdash; Some outcome\u0026lt;...\u0026gt; being constructed.  Function outcome_v2_xxx::hooks::hook_outcome_copy_construction \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;hook_outcome_copy_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept;  The default instantiation hook implementation called when a outcome is created by copying from another outcome or result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters   \u0026mdash; Some outcome\u0026lt;...\u0026gt; being constructed.  Function outcome_v2_xxx::hooks::hook_outcome_move_construction \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;hook_outcome_move_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept;  The default instantiation hook implementation called when a outcome is created by moving from another outcome or result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters   \u0026mdash; Some outcome\u0026lt;...\u0026gt; being constructed.  Function outcome_v2_xxx::hooks::hook_outcome_in_place_construction \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;hook_outcome_in_place_construction(T*, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...)\u0026nbsp;noexcept;  The default instantiation hook implementation called when a outcome is created by in place construction. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters   \u0026mdash; Some outcome\u0026lt;...\u0026gt; being constructed.  \u0026mdash; The type of in place construction occurring.  Function outcome_v2_xxx::hooks::override_outcome_exception \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;NoValuePolicy,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;override_outcome_exception(outcome\u0026lt;R, S, P, NoValuePolicy\u0026gt;*\u0026nbsp;o,\u0026nbsp;U\u0026amp;\u0026amp;\u0026nbsp;v)\u0026nbsp;noexcept;  Used in hook implementations to override the payload/exception to something other than what was constructed.\nClass outcome_v2_xxx::outcome \ntemplate\u0026nbsp;\u0026lt;class R,\u0026nbsp;class S,\u0026nbsp;class P,\u0026nbsp;class NoValuePolicy\u0026gt; class\u0026nbsp;outcome { public: \u0026#x2F;\u0026#x2F;=== Member types ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using value_type\u0026nbsp;= R; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using error_type\u0026nbsp;= S; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using exception_type\u0026nbsp;= P; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026nbsp;= S,\u0026nbsp;class\u0026nbsp;V\u0026nbsp;= P,\u0026nbsp;class\u0026nbsp;W\u0026nbsp;= policy::default_policy\u0026lt;T,U,V\u0026gt;\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using rebind\u0026nbsp;=\u0026nbsp;outcome\u0026lt;T, U, V, W\u0026gt;; protected: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct predicate; public: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using value_type_if_enabled\u0026nbsp;=\u0026nbsp;std::conditional_t\u0026lt;std::is_same\u0026lt;value_type, error_type\u0026gt;::value || std::is_same\u0026lt;value_type, exception_type\u0026gt;::value, disable_in_place_value_type, value_type\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using error_type_if_enabled\u0026nbsp;=\u0026nbsp;std::conditional_t\u0026lt;std::is_same\u0026lt;error_type, value_type\u0026gt;::value || std::is_same\u0026lt;error_type, exception_type\u0026gt;::value, disable_in_place_error_type, error_type\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using exception_type_if_enabled\u0026nbsp;=\u0026nbsp;std::conditional_t\u0026lt;std::is_same\u0026lt;exception_type, value_type\u0026gt;::value || std::is_same\u0026lt;exception_type, error_type\u0026gt;::value, disable_in_place_exception_type, exception_type\u0026gt;; protected: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026#x27;hidden\u0026#x27;\u0026nbsp;_ptr; public: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;ErrorCondEnum\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(ErrorCondEnum\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(T\u0026amp;\u0026amp; o); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::value_type_if_enabled\u0026gt; _, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::value_type_if_enabled\u0026gt; _,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::error_type_if_enabled\u0026gt; _, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::error_type_if_enabled\u0026gt; _,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::exception_type_if_enabled\u0026gt;, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::exception_type_if_enabled\u0026gt;,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;A1,\u0026nbsp;class\u0026nbsp;A2,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(A1\u0026amp;\u0026amp;\u0026nbsp;a1,\u0026nbsp;A2\u0026amp;\u0026amp;\u0026nbsp;a2, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(success_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(failure_type\u0026lt;T, U\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr outcome(failure_type\u0026lt;T, U\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(outcome\u0026lt;T, U, V, W\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(failure_type\u0026lt;T, U\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(outcome\u0026lt;T, U, V, W\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(failure_type\u0026lt;T, U\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;void swap(outcome\u0026lt;R, S, P, NoValuePolicy\u0026gt;\u0026amp;\u0026nbsp;o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); failure_type\u0026lt;outcome_v2_xxx::outcome::error_type, outcome_v2_xxx::outcome::exception_type\u0026gt; as_failure()\u0026nbsp;const\u0026nbsp;\u0026amp;; failure_type\u0026lt;outcome_v2_xxx::outcome::error_type, outcome_v2_xxx::outcome::exception_type\u0026gt; as_failure()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using\u0026nbsp;exception_type\u0026nbsp;=\u0026nbsp;std::exception_ptr; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;exception_type failure()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using\u0026nbsp;exception_type\u0026nbsp;=\u0026nbsp;\u0026#x27;hidden\u0026#x27;; \u0026#x2F;\u0026#x2F;=== assume_exception ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp; assume_exception()\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp; assume_exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026amp; assume_exception()\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026amp; assume_exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept; \u0026#x2F;\u0026#x2F;=== exception ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp; exception()\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp; exception()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026amp; exception()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026amp; exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using\u0026nbsp;error_type\u0026nbsp;=\u0026nbsp;\u0026#x27;hidden\u0026#x27;; \u0026#x2F;\u0026#x2F;=== assume_error ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp; assume_error()\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp; assume_error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp; assume_error()\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp; assume_error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept; \u0026#x2F;\u0026#x2F;=== error ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp; error()\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp; error()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;explicit\u0026nbsp;operator\u0026nbsp;bool()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool has_value()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool has_error()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool has_exception()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool has_failure()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(failure_type\u0026lt;T, void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(failure_type\u0026lt;T, void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); };  Used to return from functions one of (i) a successful value (ii) a cause of failure (ii) a different cause of failure. constexpr capable.\nThis is an extension of result\u0026lt;R, S\u0026gt; and it allows an alternative failure to be stored of type P, which can be observed with the member functions .exception() and .assume_exception(). The P state takes precedence during no-value observation over any S state, and it is possible to store S + P simultaneously such that outcome could have any one the states:\n R (value_type)\n S (error_type)\n P (exception_type)\n S + P (error_type + exception_type)\n  Similarly to result, NoValuePolicy defaults to a policy selected according to the characteristics of types S and P:\n If .value() called when there is no value_type but there is an exception_type:\n If  trait::has_exception_ptr_v\u0026lt;P\u0026gt; is true, then std::rethrow_exception(exception()|make_exception_ptr(exception())) [ policy::exception_ptr_rethrow\u0026lt;R, S, P\u0026gt; ]  If .value() called when there is no value_type but there is an error_type:\n If  trait::has_error_code_v\u0026lt;S\u0026gt; d is true, then throw std::system_error(error()|make_error_code(error())) [ policy::error_code_throw_as_system_error\u0026lt;S\u0026gt; ]\n If trait::has_exception_ptr_v\u0026lt;S\u0026gt;, then std::rethrow_exception(error()|make_exception_ptr(error())) [ policy::exception_ptr_rethrow\u0026lt;R, S, void\u0026gt; ]\n If S is void, call std::terminate() [ policy::terminate ]\n If S is none of the above, then it is undefined behaviour [ policy::all_narrow ]\n  If .exception() called when there is no exception_type:\n If trait::has_exception_ptr_v\u0026lt;P\u0026gt;, or if P is void, do throw bad_outcome_access()\n If P is none of the above, then it is undefined behaviour [policy::all_narrow]\n  If .error() called when there is no error_type:\n If trait::has_error_code_v\u0026lt;S\u0026gt;, or if trait::has_exception_ptr_v\u0026lt;S\u0026gt;, or if S is void, do throw bad_outcome_access()\n If S is none of the above, then it is undefined behaviour [policy::all_narrow]\n   Template parameters  R \u0026mdash; The optional type of the successful result (use void to disable). Cannot be a reference, a in_place_type_t\u0026lt;\u0026gt;, success\u0026lt;\u0026gt;, failure\u0026lt;\u0026gt;, an array, a function or non-destructible. S \u0026mdash; The optional type of the first failure result (use void to disable). Must be either void or DefaultConstructible. Cannot be a reference, a in_place_type_t\u0026lt;\u0026gt;, success\u0026lt;\u0026gt;, failure\u0026lt;\u0026gt;, an array, a function or non-destructible. P \u0026mdash; The optional type of the second failure result (use void to disable). Must be either void or DefaultConstructible. Cannot be a reference, a in_place_type_t\u0026lt;\u0026gt;, success\u0026lt;\u0026gt;, failure\u0026lt;\u0026gt;, an array, a function or non-destructible. NoValuePolicy \u0026mdash; Policy on how to interpret types S and P when a wide observation of a not present value occurs.  Function outcome_v2_xxx::outcome::failure \nexception_type\u0026nbsp;failure()\u0026nbsp;const\u0026nbsp;noexcept;  Synthesise exception where possible.\nRequires: trait::has_error_code_v\u0026lt;S\u0026gt; and trait::has_exception_ptr_v\u0026lt;P\u0026gt; to be true, else it does not appear.\nReturns: A synthesised exception type: if excepted, exception(); if errored, std::make_exception_ptr(std::system_error(error())); otherwise a default constructed exception type.\nFunction outcome_v2_xxx::outcome::assume_exception \n(1)\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026nbsp;assume_exception()\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; (2)\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026nbsp;assume_exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; (3)\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026amp;\u0026nbsp;assume_exception()\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept; (4)\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026amp;\u0026nbsp;assume_exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept;  Access exception without runtime checks.\nPreconditions: The outcome to have an exception state, otherwise it is undefined behaviour.\nReturns: Reference to the held exception_type according to overload.\nFunction outcome_v2_xxx::outcome::exception \n(1)\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026nbsp;exception()\u0026nbsp;\u0026amp;; (2)\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026nbsp;exception()\u0026nbsp;const\u0026nbsp;\u0026amp;; (3)\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026amp;\u0026nbsp;exception()\u0026nbsp;\u0026amp;\u0026amp;; (4)\u0026nbsp;constexpr\u0026nbsp;exception_type\u0026amp;\u0026amp;\u0026nbsp;exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;;  Access exception with runtime checks.\nReturns: Reference to the held exception_type according to overload.\nRequires: The outcome to have an exception state, else whatever NoValuePolicy says ought to happen.\nFunction outcome_v2_xxx::outcome::assume_error \n(1)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026nbsp;assume_error()\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; (2)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026nbsp;assume_error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; (3)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp;\u0026nbsp;assume_error()\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept; (4)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp;\u0026nbsp;assume_error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept;  Access error without runtime checks.\nPreconditions: The result to have a failed state, otherwise it is undefined behaviour.\nReturns: Reference to the held error_type according to overload.\nFunction outcome_v2_xxx::outcome::error \n(1)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;; (2)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;; (3)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;\u0026amp;; (4)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;;  Access error with runtime checks.\nReturns: Reference to the held error_type according to overload.\nRequires: The result to have a failed state, else whatever NoValuePolicy says ought to happen.\nConversion operator outcome_v2_xxx::outcome::operator bool \nexplicit\u0026nbsp;operator\u0026nbsp;bool()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has value.\nReturns: True if has value.\nFunction outcome_v2_xxx::outcome::has_value \nconstexpr\u0026nbsp;bool\u0026nbsp;has_value()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has value.\nReturns: True if has value.\nFunction outcome_v2_xxx::outcome::has_error \nconstexpr\u0026nbsp;bool\u0026nbsp;has_error()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has error.\nReturns: True if has error.\nFunction outcome_v2_xxx::outcome::has_exception \nconstexpr\u0026nbsp;bool\u0026nbsp;has_exception()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has exception.\nReturns: True if has exception.\nFunction outcome_v2_xxx::outcome::has_failure \nconstexpr\u0026nbsp;bool\u0026nbsp;has_failure()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has error or exception.\nReturns: True if has error or exception.\nFunction outcome_v2_xxx::outcome::operator== \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator==(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if equal to the other result.\nEffects: If a valid expression to do so, calls the operator== operation on each of the two stored items returning true if both are true. Otherwise returns false.\nThrows: Any exception the individual operator== operations might throw.\nParameters  o \u0026mdash; The other result to compare to.  Function outcome_v2_xxx::outcome::operator== \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator==(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if equal to the success type sugar.\nEffects: If a valid expression to do so, calls the operator== operation on the successful item returning true if equal. Otherwise returns false.\nThrows: Any exception the operator== operation might throw.\nParameters  o \u0026mdash; The success type sugar to compare to.  Function outcome_v2_xxx::outcome::operator== \nconstexpr\u0026nbsp;bool\u0026nbsp;operator==(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept;  True if equal to the success type sugar.\nEffects: If a valid expression to do so, calls the operator== operation on the successful item returning true if equal. Otherwise returns false.\nThrows: Any exception the operator== operation might throw.\nParameters  o \u0026mdash; The success type sugar to compare to.  Function outcome_v2_xxx::outcome::operator== \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator==(failure_type\u0026lt;T, void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if equal to the failure type sugar.\nEffects: If a valid expression to do so, calls the operator== operation on the failure item returning true if equal. Otherwise returns false.\nThrows: Any exception the operator== operation might throw.\nParameters  o \u0026mdash; The failure type sugar to compare to.  Function outcome_v2_xxx::outcome::operator!= \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator!=(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if not equal to the other result.\nEffects: If a valid expression to do so, calls the operator!= operation on each of the two stored items, returning true if any are not equal. Otherwise returns true.\nThrows: Any exception the individual operator!= operations might throw.\nParameters  o \u0026mdash; The other result to compare to.  Function outcome_v2_xxx::outcome::operator!= \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator!=(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if not equal to the success type sugar.\nEffects: If a valid expression to do so, calls the operator!= operation on the successful item returning true if not equal. Otherwise returns false.\nThrows: Any exception the operator!= operation might throw.\nParameters  o \u0026mdash; The success type sugar to compare to.  Function outcome_v2_xxx::outcome::operator!= \nconstexpr\u0026nbsp;bool\u0026nbsp;operator!=(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept;  True if not equal to the success type sugar.\nEffects: If a valid expression to do so, calls the operator!= operation on the successful item returning true if not equal. Otherwise returns false.\nThrows: Any exception the operator!= operation might throw.\nParameters  o \u0026mdash; The success type sugar to compare to.  Function outcome_v2_xxx::outcome::operator!= \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator!=(failure_type\u0026lt;T, void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if not equal to the failure type sugar.\nEffects: If a valid expression to do so, calls the operator!= operation on the failure item returning true if not equal. Otherwise returns false.\nThrows: Any exception the operator!= operation might throw.\nParameters  o \u0026mdash; The failure type sugar to compare to.  Type alias outcome_v2_xxx::outcome::value_type \nusing\u0026nbsp;value_type\u0026nbsp;= R;  The success type.\nType alias outcome_v2_xxx::outcome::error_type \nusing\u0026nbsp;error_type\u0026nbsp;= S;  The failure type.\nType alias outcome_v2_xxx::outcome::exception_type \nusing\u0026nbsp;exception_type\u0026nbsp;= P;  The exception type\nAlias template outcome_v2_xxx::outcome::rebind \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026nbsp;= S,\u0026nbsp;class\u0026nbsp;V\u0026nbsp;= P,\u0026nbsp;class\u0026nbsp;W\u0026nbsp;= policy::default_policy\u0026lt;T,U,V\u0026gt;\u0026gt; using\u0026nbsp;rebind\u0026nbsp;= outcome\u0026lt;T, U, V, W\u0026gt;;  Used to rebind this outcome to a different outcome type\nStruct outcome_v2_xxx::outcome::predicate \nstruct\u0026nbsp;predicate { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using\u0026nbsp;base\u0026nbsp;=\u0026nbsp;\u0026#x27;hidden\u0026#x27;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_value_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;T\u0026gt;,\u0026nbsp;outcome\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_value_converting_constructor\u0026lt;T\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_error_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;T\u0026gt;,\u0026nbsp;outcome\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_error_converting_constructor\u0026lt;T\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;ErrorCondEnum\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_error_condition_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;ErrorCondEnum\u0026gt;,\u0026nbsp;outcome\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_exception_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;T\u0026gt;,\u0026nbsp;outcome\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_exception_converting_constructor\u0026lt;T\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_compatible_conversion\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;outcome\u0026lt;T,\u0026nbsp;U,\u0026nbsp;V,\u0026nbsp;W\u0026gt;,\u0026nbsp;outcome\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_compatible_conversion\u0026lt;T,\u0026nbsp;U,\u0026nbsp;V,\u0026nbsp;W\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_value_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;value_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;value_type,\u0026nbsp;Args...\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_error_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;error_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;error_type,\u0026nbsp;Args...\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_exception_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;exception_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;exception_type,\u0026nbsp;Args...\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_value_error_exception_constructor\u0026nbsp;=\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_inplace_value_error_exception_constructor\u0026lt;Args...\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using\u0026nbsp;choose_inplace_value_error_exception_constructor\u0026nbsp;= typename base::choose_inplace_value_error_exception_constructor\u0026lt;Args...\u0026gt;; };  Requirement predicates for outcome.\nUnexposed entity outcome_v2_xxx::outcome::predicate::enable_value_converting_constructor \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_value_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;T\u0026gt;,\u0026nbsp;outcome\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_value_converting_constructor\u0026lt;T\u0026gt;;  Predicate for the value converting constructor to be available.\nUnexposed entity outcome_v2_xxx::outcome::predicate::enable_error_converting_constructor \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_error_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;T\u0026gt;,\u0026nbsp;outcome\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_error_converting_constructor\u0026lt;T\u0026gt;;  Predicate for the error converting constructor to be available.\nUnexposed entity outcome_v2_xxx::outcome::predicate::enable_error_condition_converting_constructor \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;ErrorCondEnum\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_error_condition_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;ErrorCondEnum\u0026gt;,\u0026nbsp;outcome\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt;;  Predicate for the error condition converting constructor to be available.\nUnexposed entity outcome_v2_xxx::outcome::predicate::enable_compatible_conversion \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_compatible_conversion\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;outcome\u0026lt;T,\u0026nbsp;U,\u0026nbsp;V,\u0026nbsp;W\u0026gt;,\u0026nbsp;outcome\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_compatible_conversion\u0026lt;T,\u0026nbsp;U,\u0026nbsp;V,\u0026nbsp;W\u0026gt;;  Predicate for the converting constructor from a compatible input to be available.\nUnexposed entity outcome_v2_xxx::outcome::predicate::enable_inplace_value_constructor \ntemplate\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_value_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;value_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;value_type,\u0026nbsp;Args...\u0026gt;::value;  Predicate for the inplace construction of value to be available.\nUnexposed entity outcome_v2_xxx::outcome::predicate::enable_inplace_error_constructor \ntemplate\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_error_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;error_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;error_type,\u0026nbsp;Args...\u0026gt;::value;  Predicate for the inplace construction of error to be available.\nUnexposed entity outcome_v2_xxx::outcome::predicate::enable_inplace_exception_constructor \ntemplate\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_exception_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;exception_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;exception_type,\u0026nbsp;Args...\u0026gt;::value;  Predicate for the inplace construction of exception to be available.\nType alias outcome_v2_xxx::outcome::value_type_if_enabled \nusing\u0026nbsp;value_type_if_enabled\u0026nbsp;=\u0026nbsp;std::conditional_t\u0026lt;std::is_same\u0026lt;value_type, error_type\u0026gt;::value || std::is_same\u0026lt;value_type, exception_type\u0026gt;::value, disable_in_place_value_type, value_type\u0026gt;;  Used to disable in place type construction when value_type is ambiguous with error_type or exception_type.\nType alias outcome_v2_xxx::outcome::error_type_if_enabled \nusing\u0026nbsp;error_type_if_enabled\u0026nbsp;=\u0026nbsp;std::conditional_t\u0026lt;std::is_same\u0026lt;error_type, value_type\u0026gt;::value || std::is_same\u0026lt;error_type, exception_type\u0026gt;::value, disable_in_place_error_type, error_type\u0026gt;;  Used to disable in place type construction when error_type is ambiguous with value_type or exception_type.\nType alias outcome_v2_xxx::outcome::exception_type_if_enabled \nusing\u0026nbsp;exception_type_if_enabled\u0026nbsp;=\u0026nbsp;std::conditional_t\u0026lt;std::is_same\u0026lt;exception_type, value_type\u0026gt;::value || std::is_same\u0026lt;exception_type, error_type\u0026gt;::value, disable_in_place_exception_type, exception_type\u0026gt;;  Used to disable in place type construction when exception_type is ambiguous with value_type or error_type.\nConstructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;outcome(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Converting constructor to a successful outcome.\nEffects: Initialises the outcome with a value_type.\nRequires: Type T is implicitly constructible to value_type, is not implicitly constructible to error_type, is not implicitly constructible to exception_type and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters  t \u0026mdash; The value from which to initialise the value_type.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;outcome(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Converting constructor to an errored outcome.\nEffects: Initialises the outcome with a error_type.\nRequires: Type T is implicitly constructible to error_type, is not implicitly constructible to value_type, is not implicitly constructible to exception_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters  t \u0026mdash; The value from which to initialise the error_type.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;ErrorCondEnum\u0026gt; constexpr\u0026nbsp;outcome(ErrorCondEnum\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Special error condition converting constructor to an errored outcome.\nEffects: Initialises the outcome with a error_type constructed via make_error_code(t).\nRequires: std::is_error_condition_enum\u0026lt;ErrorCondEnum\u0026gt; must be true, ErrorCondEnum is not implicitly constructible to value_type, error_type nor exception_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Finally, the expression error_type(make_error_code(ErrorCondEnum())) must be valid.\nThrows: Any exception the construction of error_type(make_error_code(t)) might throw.\nParameters  t \u0026mdash; The error condition from which to initialise the error_type.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;outcome(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Converting constructor to an excepted outcome.\nEffects: Initialises the outcome with a exception_type.\nRequires: trait::is_exception_ptr\u0026lt;P\u0026gt; must be true; Type T is implicitly constructible to exception_type, is not implicitly constructible to value_type, is not implicitly constructible to error_type, and is not outcome\u0026lt;R, S, P\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of exception_type(T) might throw.\nParameters  t \u0026mdash; The value from which to initialise the exception_type.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;outcome(T\u0026amp;\u0026amp; o);  Explicit converting constructor from a compatible ValueOrError type.\nEffects: Initialises the outcome with the contents of the compatible input.\nRequires: That convert::value_or_error\u0026lt;outcome, std::decay_t\u0026lt;T\u0026gt;\u0026gt;{}(std::forward\u0026lt;T\u0026gt;(o)) be available. The default implementation will consume T‚Äôs matching the ValueOrError concept type. ValueOrError concept matches any type with a value_type, an error_type, a .value(), an .error() and a .has_value().\nParameters  o \u0026mdash; The input for which a convert::value_or_error\u0026lt;outcome, std::decay_t\u0026lt;T\u0026gt;\u0026gt;{}(std::forward\u0026lt;T\u0026gt;(o)) is available.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt; constexpr\u0026nbsp;outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit converting copy constructor from a compatible outcome type.\nEffects: Initialises the outcome with a copy of the compatible outcome.\nRequires: Both outcome‚Äôs value_type, error_type, and exception_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), error_type(U) or exception_type(V) might throw.\nParameters  o \u0026mdash; The compatible outcome.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt; constexpr\u0026nbsp;outcome(outcome\u0026lt;T, U, V, W\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit converting move constructor from a compatible outcome type.\nEffects: Initialises the outcome with a move of the compatible outcome.\nRequires: Both outcome‚Äôs value_type, error_type, and exception_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), error_type(U) or exception_type(V) might throw.\nParameters  o \u0026mdash; The compatible outcome.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; constexpr\u0026nbsp;outcome(result\u0026lt;T, U, V\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit converting copy constructor from a compatible result type.\nEffects: Initialises the outcome with a copy of the compatible result.\nRequires: Both outcome‚Äôs value_type and error_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), error_type(U) or exception_type() might throw.\nParameters  o \u0026mdash; The compatible result.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; constexpr\u0026nbsp;outcome(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit converting move constructor from a compatible result type.\nEffects: Initialises the outcome with a move of the compatible result.\nRequires: Both outcome‚Äôs value_type and error_type need to be constructible, or the source void.\nThrows: Any exception the construction of value_type(T), error_type(U) or exception_type() might throw.\nParameters  o \u0026mdash; The compatible result.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::value_type_if_enabled\u0026gt; _, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters  _ \u0026mdash; Tag type to indicate we are doing in place construction of value_type. args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::value_type_if_enabled\u0026gt; _,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Inplace constructor to a successful value.\nEffects: Initialises the outcome with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters  _ \u0026mdash; Tag type to indicate we are doing in place construction of value_type. il \u0026mdash; An initializer list with which to in place construct. args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::error_type_if_enabled\u0026gt; _, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters  _ \u0026mdash; Tag type to indicate we are doing in place construction of error_type. args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::error_type_if_enabled\u0026gt; _,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Inplace constructor to an unsuccessful error.\nEffects: Initialises the outcome with a error_type.\nRequires: The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters  _ \u0026mdash; Tag type to indicate we are doing in place construction of error_type. il \u0026mdash; An initializer list with which to in place construct. args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::exception_type_if_enabled\u0026gt;, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Inplace constructor to an unsuccessful exception.\nEffects: Initialises the outcome with an exception_type.\nRequires: exception_type is void or Args... are constructible to exception_type.\nThrows: Any exception the construction of exception_type(Args...) might throw.\nParameters  args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;outcome(in_place_type_t\u0026lt;outcome_v2_xxx::outcome::exception_type_if_enabled\u0026gt;,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Inplace constructor to an unsuccessful exception.\nEffects: Initialises the outcome with an exception_type.\nRequires: The initializer list + Args... are constructible to exception_type.\nThrows: Any exception the construction of exception_type(il, Args...) might throw.\nParameters  il \u0026mdash; An initializer list with which to in place construct. args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;A1,\u0026nbsp;class\u0026nbsp;A2,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;outcome(A1\u0026amp;\u0026amp;\u0026nbsp;a1,\u0026nbsp;A2\u0026amp;\u0026amp;\u0026nbsp;a2, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit inplace constructor to successful value, or unsuccessful error, or unsuccessful exception.\nEffects: Calls the appropriate in_place_type_t\u0026lt;...\u0026gt; constructor depending on constructibility of args.\nRequires: That the args can construct exactly one of value_type or error_type or exception_type.\nThrows: Any exception the in_place_type_t\u0026lt;...\u0026gt; constructor might throw.\nParameters  args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::outcome::outcome \nconstexpr\u0026nbsp;outcome(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a successful outcome.\nEffects: Initialises the outcome with a default constructed success type.\nRequires: value_type to be default constructible, or void.\nThrows: Any exception the construction of value_type() might throw.\nParameters  o \u0026mdash; The compatible success type sugar.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;outcome(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a successful outcome.\nEffects: Initialises the outcome with a copy of the value in the type sugar.\nRequires: Both outcome and success‚Äô value_type need to be constructible. The source cannot be void.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters  o \u0026mdash; The compatible success type sugar.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;outcome(success_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a successful outcome.\nEffects: Initialises the outcome with a move of the value in the type sugar.\nRequires: Both outcome and success‚Äô value_type need to be constructible. The source cannot be void.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters  o \u0026mdash; The compatible success type sugar.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;outcome(failure_type\u0026lt;T, U\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a failure outcome.\nEffects: Initialises the outcome with a copy of the error and/or exception in the type sugar.\nRequires: Both outcome and failure‚Äôs error_type and exception_type need to be constructible, or the source can be void.\nThrows: Any exception the construction of error_type(T) and/or exception_type(U) might throw.\nParameters  o \u0026mdash; The compatible failure type sugar.  Constructor outcome_v2_xxx::outcome::outcome \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;outcome(failure_type\u0026lt;T, U\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a failure outcome.\nEffects: Initialises the outcome with a copy of the error and/or exception in the type sugar.\nRequires: Both outcome and failure‚Äôs error_type and exception_type need to be constructible, or the source can be void.\nThrows: Any exception the construction of error_type(T) and/or exception_type(U) might throw.\nParameters  o \u0026mdash; The compatible failure type sugar.  Function outcome_v2_xxx::outcome::operator== \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator==(outcome\u0026lt;T, U, V, W\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if equal to the other outcome.\nEffects: If a valid expression to do so, calls the operator== operation on each of the three stored items returning true if both are true. Otherwise returns false.\nThrows: Any exception the individual operator== operations might throw.\nParameters  o \u0026mdash; The other outcome to compare to.  Function outcome_v2_xxx::outcome::operator== \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator==(failure_type\u0026lt;T, U\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if equal to the failure type sugar.\nEffects: If a valid expression to do so, calls the operator== operation on the failure items returning true if equal. Otherwise returns false.\nThrows: Any exception the operator== operations might throw.\nParameters  o \u0026mdash; The failure type sugar to compare to.  Function outcome_v2_xxx::outcome::operator!= \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;W\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator!=(outcome\u0026lt;T, U, V, W\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if not equal to the other outcome.\nEffects: If a valid expression to do so, calls the operator!= operation on each of the three stored items, returning true if any are not equal. Otherwise returns true.\nThrows: Any exception the individual operator!= operations might throw.\nParameters  o \u0026mdash; The other outcome to compare to.  Function outcome_v2_xxx::outcome::operator!= \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator!=(failure_type\u0026lt;T, U\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if not equal to the failure type sugar.\nEffects: If a valid expression to do so, calls the operator!= operation on the failure items returning true if not equal. Otherwise returns false.\nThrows: Any exception the operator!= operations might throw.\nParameters  o \u0026mdash; The failure type sugar to compare to.  Function outcome_v2_xxx::outcome::swap \nvoid\u0026nbsp;swap(outcome\u0026lt;R, S, P, NoValuePolicy\u0026gt;\u0026amp;\u0026nbsp;o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Swaps this result with another result\nEffects: Any R and/or S is swapped along with the metadata tracking them.\nFunction outcome_v2_xxx::outcome::as_failure \nfailure_type\u0026lt;outcome_v2_xxx::outcome::error_type, outcome_v2_xxx::outcome::exception_type\u0026gt;\u0026nbsp;as_failure()\u0026nbsp;const\u0026nbsp;\u0026amp;;  Returns this outcome as a failure_type with any errored and/or excepted state copied.\nRequires: This outcome to have a failed state, else whatever assume_error() would do.\nFunction outcome_v2_xxx::outcome::as_failure \nfailure_type\u0026lt;outcome_v2_xxx::outcome::error_type, outcome_v2_xxx::outcome::exception_type\u0026gt;\u0026nbsp;as_failure()\u0026nbsp;\u0026amp;\u0026amp;;  Returns this outcome as a failure_type with any errored and/or excepted state moved.\nRequires: This outcome to have a failed state, else whatever assume_error() would do.\nFunction outcome_v2_xxx::operator== \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator==(result\u0026lt;T, U, V\u0026gt;\u0026nbsp;const\u0026amp; a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026nbsp;const\u0026amp; b)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if the result is equal to the outcome\nRemarks: Implemented as b == a.\nRequires: That the expression b == a is a valid expression.\nThrows: Any exception that b == a might throw.\nParameters  a \u0026mdash; The result to compare. b \u0026mdash; The outcome to compare.  Function outcome_v2_xxx::operator!= \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V,\u0026nbsp;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator!=(result\u0026lt;T, U, V\u0026gt;\u0026nbsp;const\u0026amp; a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026nbsp;const\u0026amp; b)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if the result is not equal to the outcome\nRemarks: Implemented as b != a.\nRequires: That the expression b != a is a valid expression.\nThrows: Any exception that b != a might throw.\nParameters  a \u0026mdash; The result to compare. b \u0026mdash; The outcome to compare.  Function outcome_v2_xxx::swap \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; void\u0026nbsp;swap(outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp;\u0026nbsp;a, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp;\u0026nbsp;b)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Specialise swap for outcome.\nEffects: Calls a.swap(b).\n\nFunction outcome_v2_xxx::hooks::override_outcome_exception \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;NoValuePolicy,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;override_outcome_exception(outcome\u0026lt;R, S, P, NoValuePolicy\u0026gt;*\u0026nbsp;o,\u0026nbsp;U\u0026amp;\u0026amp;\u0026nbsp;v)\u0026nbsp;noexcept;  Used to set/override an exception during a construction hook implementation.\nEffects: Sets the exception of the outcome to the given value.\nParameters  o \u0026mdash; The outcome you wish to change. v \u0026mdash; Exception to be set.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/result/",
	"title": "result&lt;T, EC&gt;",
	"tags": ["result", "try", "namespace"],
	"description": "Gentle introduction to writing code with simple success-or-failure return types.",
	"content": " Outcome 2.0 namespace It is recommended that you refer to entities from this Outcome 2.0 via the following namespace alias:\nnamespace outcome = OUTCOME_V2_NAMESPACE; View this code on Github As patches and modifications are applied to this library, namespaces get permuted in order not to break any backward compatibility. At some point namespace outcome::v2 will be defined, and this will be the prefered namespace. Until then OUTCOME_V2_NAMESPACE denotes the most recently updated version, getting closer to outcome::v2.\nCreating result\u0026lt;\u0026gt; We will define a function that converts an std::string to an int. This function can fail for a number of reasons; if it does we want to communicate the failure reason.\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept; View this code on Github Class template  result\u0026lt;T, EC\u0026gt; has two template parameters. The first (T) represents the type of the object returned from the function upon success; the second (EC) is the type of object containing information about the reason for failure when the function fails. A result\u0026lt;T, EC\u0026gt; object either stores a T or an EC at any given moment, and is therefore conceptually similar to variant\u0026lt;T, EC\u0026gt;. EC is defaulted to std::error_code. If both T and EC are trivially copyable, result\u0026lt;T, EC\u0026gt; is also trivially copyable.\nNow, we will define an enumeration describing different failure situations during conversion.\nenum class ConversionErrc { EmptyString = 1, // 0 is never an error  IllegalChar = 2, TooLong = 3, }; // all boilerplate necessary to plug ConversionErrc // into std::error_code framework View this code on Github Assume we have plugged it into std::error_code framework, as described in this section.\nOne notable effect of such plugging is that ConversionErrc is now convertible to std::error_code. Now we can implement function convert as follows:\noutcome::result\u0026lt;int\u0026gt; convert(const std::string\u0026amp; str) noexcept { if (str.empty()) return ConversionErrc::EmptyString; if (!std::all_of(str.begin(), str.end(), ::isdigit)) return ConversionErrc::IllegalChar; if (str.length() \u0026gt; 9) return ConversionErrc::TooLong; return atoi(str.c_str()); } View this code on Github result\u0026lt;T, EC\u0026gt; is convertible from any T2 convertible to T as well as any EC2 convertible to EC, provided that there is no constructability possible in either direction between T and EC. If there is, all implicit conversion is disabled, and you will need to use one of the tagged constructors:\noutcome::result\u0026lt;int\u0026gt; r {outcome::in_place_type\u0026lt;std::error_code\u0026gt;, ConversionErrc::EmptyString}; outcome::result\u0026lt;int\u0026gt; s {outcome::in_place_type\u0026lt;int\u0026gt;, 1}; View this code on Github Or use helper factory functions:\noutcome::result\u0026lt;int\u0026gt; r = outcome::failure(ConversionErrc::EmptyString); outcome::result\u0026lt;int\u0026gt; s = outcome::success(1); View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/tidylib/",
	"title": "The HTMLTidy library",
	"tags": [],
	"description": "",
	"content": "// There actually is a library for tidying HTML into XHTML called HTMLTidy // See http://www.html-tidy.org/ // HTMLTidy is actually a great tool, I highly recommend it.  // This isn\u0026#39;t the API for Tidy, but let\u0026#39;s assume it\u0026#39;s a C library returning // errno domained error codes. out must be freed with free() after use. extern \u0026#34;C\u0026#34; int tidy_html(char **out, size_t *outlen, const char *in, size_t inlen); View this code on Github A C API may not initially appear to be a T|E based API, but if failure returns some domained error code and causes no other effects, and success returns some value, then it is effectively a \u0026ldquo;split\u0026rdquo; T|E API. The above is an example of exactly that form of \u0026ldquo;split\u0026rdquo; T|E API.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/file_handle/",
	"title": "A file handle",
	"tags": [],
	"description": "",
	"content": "Borrowing from afio::file_handle which uses this design pattern, here is a simplified file_handle implementation:\nclass file_handle { int _fd{-1}; // file descriptor  struct stat _stat { 0 }; // stat of the fd at open  // Phase 1 private constexpr constructor  constexpr file_handle() {} public: using path_type = filesystem::path; //! The behaviour of the handle: does it read, read and write, or atomic append?  enum class mode : unsigned char // bit 0 set means writable  { unchanged = 0, none = 2, //!\u0026lt; No ability to read or write anything, but can synchronise (SYNCHRONIZE or 0)  attr_read = 4, //!\u0026lt; Ability to read attributes (FILE_READ_ATTRIBUTES|SYNCHRONIZE or O_RDONLY)  attr_write = 5, //!\u0026lt; Ability to read and write attributes (FILE_READ_ATTRIBUTES|FILE_WRITE_ATTRIBUTES|SYNCHRONIZE or O_RDONLY)  read = 6, //!\u0026lt; Ability to read (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONISE or O_RDONLY)  write = 7, //!\u0026lt; Ability to read and write (READ_CONTROL|FILE_READ_DATA|FILE_READ_ATTRIBUTES|FILE_READ_EA|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONISE or O_RDWR)  append = 9 //!\u0026lt; All mainstream OSs and CIFS guarantee this is atomic with respect to all other appenders (FILE_APPEND_DATA|SYNCHRONISE or O_APPEND)  }; // Moves but not copies permitted  file_handle(const file_handle \u0026amp;) = delete; file_handle(file_handle \u0026amp;\u0026amp;o) noexcept : _fd(o._fd) { o._fd = -1; } file_handle \u0026amp;operator=(const file_handle \u0026amp;) = delete; file_handle \u0026amp;operator=(file_handle \u0026amp;\u0026amp;o) noexcept { this-\u0026gt;~file_handle(); new(this) file_handle(std::move(o)); return *this; } // Destruction closes the handle  ~file_handle() { if(_fd != -1) { if(-1 == ::close(_fd)) { int e = errno; std::cerr \u0026lt;\u0026lt; \u0026#34;FATAL: Closing the fd during destruction failed due to \u0026#34; \u0026lt;\u0026lt; strerror(e) \u0026lt;\u0026lt; std::endl; std::terminate(); } _fd = -1; } } // Phase 2 static member constructor function, which cannot throw  static inline outcome::result\u0026lt;file_handle\u0026gt; file(path_type path, mode mode = mode::read) noexcept; }; View this code on Github Note the default member initialisers, these are particularly convenient for implementing phase 1 of construction. Note also the constexpr constructor, which thanks to the default member initialisers is otherwise empty.\nFile handles are very expensive to copy as they involve a syscall to duplicate the file descriptor, so we enable moves only.\nThe destructor closes the file descriptor if it is not -1, and if the close fails, seeing as there is nothing else we can do without leaking the file descriptor, we fatal exit the process.\nFinally we declare the phase 2 constructor which is a static member function.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/adl_bridging/",
	"title": "ADL bridging",
	"tags": ["adl-bridging"],
	"description": "",
	"content": "In a previous section, we used the failure_info type to create the ADL bridge into the namespace where the ADL discovered  throw_as_system_error_with_payload() function was to be found.\nHere we do the same, but more directly by creating a thin clone of std::error_code into the local namespace. This ensures that this namespace will be searched by the compiler when discovering the event hooks.\nnamespace error_code_extended { // Use the error_code type as the ADL bridge for the hooks by creating a type here  // It can be any type that your localised result uses, including the value type but  // by localising the error code type here you prevent nasty surprises later when the  // value type you use doesn\u0026#39;t trigger the ADL bridge.  struct error_code : public std::error_code { // literally passthrough  using std::error_code::error_code; error_code() = default; error_code(std::error_code ec) : std::error_code(ec) { } }; // Localise result and outcome to using the local error_code so this namespace gets looked up for the hooks  template \u0026lt;class R\u0026gt; using result = OUTCOME_V2_NAMESPACE::result\u0026lt;R, error_code\u0026gt;; template \u0026lt;class R\u0026gt; using outcome = OUTCOME_V2_NAMESPACE::outcome\u0026lt;R, error_code /*, std::exception_ptr */\u0026gt;; } View this code on Github For convenience, we template alias local copies of result and outcome in this namespace bound to the ADL bridging error_code.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/",
	"title": "API reference",
	"tags": [],
	"description": "",
	"content": " Project index  CXX_DECLARE_RESULT \u0026mdash; Declares a C struct representation of result\u0026lt;R, S\u0026gt;.\n CXX_DECLARE_RESULT_EC \u0026mdash; Declares a C struct representation of result\u0026lt;R, std::error_code\u0026gt;.\n CXX_RESULT \u0026mdash; A reference to a previously declared struct by CXX_DECLARE_RESULT(R, RD, S, SD)\n CXX_RESULT_EC \u0026mdash; A reference to a previously declared struct by CXX_DECLARE_RESULT_EC(R, RD)\n CXX_RESULT_ERROR \u0026mdash; C11 generic selecting a result struct‚Äôs error or code integer member.\n CXX_RESULT_ERROR_IS_ERRNO \u0026mdash; True if a result struct‚Äôs error or code is an errno domain code suitable for setting errno with.\n CXX_RESULT_HAS_ERROR \u0026mdash; True if a result struct has a valid error\n CXX_RESULT_HAS_VALUE \u0026mdash; True if a result struct has a valid value\n CXX_RESULT_SET_ERRNO \u0026mdash; Convenience macro setting errno to a result struct‚Äôs errno compatible error if present, or EAGAIN if errored but incompatible.\n OUTCOME_TRY \u0026mdash; If the outcome returned by expression ‚Ä¶ is not valued, propagate any failure by immediately returning that failure immediately, else set v to the unwrapped value.\n OUTCOME_TRYV \u0026mdash; If the outcome returned by expression ‚Ä¶ is not valued, propagate any failure by immediately returning that failure state immediately\n OUTCOME_TRYX \u0026mdash; If the outcome returned by expression ‚Ä¶ is not valued, propagate any failure by immediately returning that failure state immediately, else become the unwrapped value as an expression. This makes OUTCOME_TRYX(expr) an expression which can be used exactly like the try operator in other languages.\n cxx_error_code \u0026mdash; A C struct representation of std::error_code.\n Namespace outcome_v2_xxx::convert \nNamespace for injected convertibility\n ValueOrError\n ValueOrNone\n value_or_error \u0026mdash; Default converter for types matching the ValueOrError concept.\n  Namespace outcome_v2_xxx::hooks \nNamespace containing hooks used for intercepting and manipulating result/outcome\n hook_outcome_construction \u0026mdash; The default instantiation hook implementation called when a outcome is first created by conversion from one of its possible types. Does nothing.\n hook_outcome_copy_construction \u0026mdash; The default instantiation hook implementation called when a outcome is created by copying from another outcome or result. Does nothing.\n hook_outcome_in_place_construction \u0026mdash; The default instantiation hook implementation called when a outcome is created by in place construction. Does nothing.\n hook_outcome_move_construction \u0026mdash; The default instantiation hook implementation called when a outcome is created by moving from another outcome or result. Does nothing.\n hook_result_construction \u0026mdash; The default instantiation hook implementation called when a result is first created by conversion from one of its possible types. Does nothing.\n hook_result_copy_construction \u0026mdash; The default instantiation hook implementation called when a result is created by copying from another result. Does nothing.\n hook_result_in_place_construction \u0026mdash; The default instantiation hook implementation called when a result is created by in place construction. Does nothing.\n hook_result_move_construction \u0026mdash; The default instantiation hook implementation called when a result is created by moving from another result. Does nothing.\n override_outcome_exception \u0026mdash; Used in hook implementations to override the payload/exception to something other than what was constructed.\n set_spare_storage \u0026mdash; Sets the sixteen bits of spare storage in a result or outcome.\n spare_storage \u0026mdash; Get the sixteen bits of spare storage in a result or outcome.\n  Namespace outcome_v2_xxx::policy \nNamespace for policies\n all_narrow \u0026mdash; Policy which treats wide checks as narrow checks.\n default_policy \u0026mdash; Default policy selector.\n error_code \u0026mdash; Used by policies to extract a std::error_code from some input T via ADL discovery of some make_error_code(T) function.\n error_code_throw_as_system_error \u0026mdash; Policy interpreting EC as a type for which trait::has_error_code_v\u0026lt;EC\u0026gt; is true.\n exception_ptr \u0026mdash; Used by policies to extract a std::exception_ptr from some input T via ADL discovery of some make_exception_ptr(T) function.\n exception_ptr_rethrow \u0026mdash; Policy interpreting EC or E as a type for which trait::has_exception_ptr_v\u0026lt;EC|E\u0026gt; is true.\n terminate \u0026mdash; Policy implementing any wide attempt to access the successful state as calling std::terminate\n throw_as_system_error_with_payload \u0026mdash; Override to define what the policies which throw a system error with payload ought to do for some particular result.error().\n throw_bad_result_access \u0026mdash; Policy which throws bad_result_access_with\u0026lt;EC\u0026gt; or bad_result_access during wide checks.\n  Namespace outcome_v2_xxx::trait \nNamespace for traits\n has_error_code \u0026mdash; Trait for whether a free function make_error_code(T) returning a std::error_code exists or not.\n has_error_code_v \u0026mdash; Trait for whether a free function make_error_code(T) returning a std::error_code exists or not.\n has_exception_ptr \u0026mdash; Trait for whether a free function make_exception_ptr(T) returning a std::exception_ptr exists or not.\n has_exception_ptr_v \u0026mdash; Trait for whether a free function make_exception_ptr(T) returning a std::exception_ptr exists or not.\n  Namespace outcome_v2_xxx \n bad_outcome_access \u0026mdash; Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn‚Äôt present.\n bad_result_access \u0026mdash; Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn‚Äôt present.\n bad_result_access_with \u0026mdash; Thrown when you try to access a value in a result\u0026lt;R, S\u0026gt; which isn‚Äôt present.\n checked \u0026mdash; A ‚Äúchecked‚Äù edition of result\u0026lt;T, E\u0026gt; which resembles fairly closely a std::expected\u0026lt;T, E\u0026gt;.\n error_from_exception \u0026mdash; Utility function which tries to match the exception in the pointer provided to an equivalent error code. Ought to work for all standard STL types.\n failure \u0026mdash; Returns type sugar for implicitly constructing a result\u0026lt;T\u0026gt; with a failure state.\n failure_type \u0026mdash; Type sugar for implicitly constructing a result\u0026lt;\u0026gt; with a failure state of error code and exception.\n in_place_type \u0026mdash; Aliases std::in_place_type\u0026lt;T\u0026gt; if on C++ 17 or later, else defined locally.\n in_place_type_t \u0026mdash; Aliases std::in_place_type_t\u0026lt;T\u0026gt; if on C++ 17 or later, else defined locally.\n is_outcome \u0026mdash; True if an outcome\n is_outcome_v \u0026mdash; True if an outcome\n is_result \u0026mdash; True if a result\n is_result_v \u0026mdash; True if a result\n operator!= \u0026mdash; True if the result is not equal to the outcome\n operator\u0026lt;\u0026lt; \u0026mdash; Serialise a result. Format is status_unsigned [value][error]. Spare storage is preserved.\n operator== \u0026mdash; True if the result is equal to the outcome\n operator\u0026gt;\u0026gt; \u0026mdash; Deserialise a result. Format is status_unsigned [value][error]. Spare storage is preserved.\n outcome \u0026mdash; Used to return from functions one of (i) a successful value (ii) a cause of failure (ii) a different cause of failure. constexpr capable.\n print \u0026mdash; Debug print a result into a form suitable for human reading. Format is value|error. If the error type is error_code, appends \u0026quot; (ec.message())\u0026quot; afterwards.\n result \u0026mdash; Used to return from functions either (i) a successful value (ii) a cause of failure. constexpr capable.\n success \u0026mdash; Returns type sugar for implicitly constructing a result\u0026lt;T\u0026gt; with a successful state, default constructing T if necessary.\n success_type \u0026mdash; Type sugar for implicitly constructing a result\u0026lt;\u0026gt; with a successful state.\n swap \u0026mdash; Specialise swap for result.\n try_operation_return_as \u0026mdash; Customisation point for changing what the OUTCOME_TRY macros do. This function defaults to returning std::forward\u0026lt;T\u0026gt;(v).as_failure().\n try_throw_std_exception_from_error \u0026mdash; Utility function which tries to throw the equivalent STL exception type for some given error code, not including system_error.\n unchecked \u0026mdash; An ‚Äúunchecked‚Äù edition of result\u0026lt;T, E\u0026gt; which does no special handling of specific E types at all.\n   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/policies/cast/",
	"title": "Casting workaround",
	"tags": [],
	"description": "",
	"content": "The templated Impl type on each policy function is decltype(*this) of the part of Outcome\u0026rsquo;s internal implementation which calls the policy. It therefore may be quite removed from the actual outcome type in play, and thus the .exception() member function and others belonging to outcome only will not be immediately visible.\nHence a very common thing you\u0026rsquo;ll need to do is static cast to a more derived form before use like this:\ntemplate \u0026lt;class T, class EC, class E\u0026gt; struct outcome_policy { /*! Performs a wide check of state, used in the value() functions. \\effects If outcome does not have a value, if it has an exception it rethrows it via `std::rethrow_exception()`, if has an error it throws a `std::system_error(error())`, else it throws `bad_outcome_access`. */ template \u0026lt;class Impl\u0026gt; static constexpr void wide_value_check(const Impl \u0026amp;self) { // All of the have_*() state check functions are always present in all Impl types  if(!self.have_value()) { if(self.have_exception()) { // .value() is implemented by the result part of Outcome. It knows nothing  // of outcome\u0026#39;s .exception(), so we need to cast to the derived type first.  const MyOutcomeType \u0026amp;_self = static_cast\u0026lt;const MyOutcomeType \u0026amp;\u0026gt;(self); // Note this will invoke narrow_exception_check() in this policy  std::rethrow_exception(_self.assume_exception()); } if(self.have_error()) { throw std::system_error(make_error_code(self.assume_error())); } throw bad_outcome_access(\u0026#34;no value\u0026#34;); } } }; View this code on Github Note that const-ness and lvalue/rvalue-ness is propagated to Impl \u0026amp;\u0026amp;self, so if the result or outcome is a const rvalue and the user calls .value() on that, the wide_value_check() will see a const rvalue self. This lets you move from self when implementing the wide value check appropriately.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/enums/",
	"title": "Error code enums",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s replace err with something likely in many people\u0026rsquo;s code, a strongly typed enum:\nstruct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; enum class err { success, // REMEMBER it is best practice to always put \u0026#34;success\u0026#34;  failure1, // with value 0 as your first item in any error code  failure2 // enum, even if you never use it.  }; result\u0026lt;udt, err\u0026gt; res(err::failure1); // What happens here? What exception type is thrown?  try { std::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl; } catch(const std::exception \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/example/",
	"title": "Example C++ function",
	"tags": [],
	"description": "",
	"content": "Let us start with a simple C++ function which we wish to make available to C code:\n// Fill the supplied buffer with the integer v converted to a string, returning // length of string minus null terminator extern \u0026#34;C\u0026#34; outcome::result\u0026lt;size_t\u0026gt; to_string(char *buffer, size_t bufferlen, int v) noexcept { try { // Could throw an exception!  std::string temp(std::to_string(v)); // Will this string exceed the supplied buffer?  if(temp.size() + 1 \u0026gt; bufferlen) return std::errc::no_buffer_space; // Copy the string into the supplied buffer, and return length of string  memcpy(buffer, temp.data(), temp.size() + 1); return temp.size(); } catch(...) { // This utility function rethrows the C++ exception, matching it  // against every standard library exception and generating an  // error code exactly matching it if possible. So, if the  // string creation threw std::bad_alloc, that would be converted  // into make_error_code(std::errc::not_enough_memory).  return outcome::error_from_exception(); } } View this code on Github A surprise to some may be that one can return an outcome::result\u0026lt;size_t\u0026gt; from a C function! This is because if for some result\u0026lt;T, EC\u0026gt; where both T and EC have standard layout and are trivially copyable, then Outcome guarantees so will result\u0026lt;T, EC\u0026gt;. Thus outcome::result\u0026lt;size_t\u0026gt; is a perfectly legal C type, and can be returned directly to C code.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/result/inspecting/",
	"title": "Inspecting result&lt;T, EC&gt;",
	"tags": ["nodiscard", "value", "error", "try"],
	"description": "",
	"content": "Suppose we will be writing a function print_half that takes an integer number (however big) represented as an std::string and outputs a number which is twice smaller:\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text); View this code on Github The type result\u0026lt;void\u0026gt; means that there is no value to be retuned upon success, but that the operation might still fail, and we may be interested in inspecting the cause of the failure. The class template result\u0026lt;\u0026gt; is declared with the attribute [[nodiscard]], which means the compiler will warn you if you forget to inspect the returned object (in C++ 17 or later).\nThe implementation will do the following: if the integral number can be represented by an int, we will convert to int and use its arithmetical operations. If the number is too large, we will fall back to using a custom BigInt implementation that needs to allocate memory. In the implementation we will use the function convert defined in the previous section.\noutcome::result\u0026lt;void\u0026gt; print_half(const std::string\u0026amp; text) { if (outcome::result\u0026lt;int\u0026gt; r = convert(text)) // #1  { std::cout \u0026lt;\u0026lt; (r.value() / 2) \u0026lt;\u0026lt; std::endl; // #2  } else { if (r.error() == ConversionErrc::TooLong) // #3  { OUTCOME_TRY (i, (BigInt::fromString(text)));// #4  std::cout \u0026lt;\u0026lt; i.half() \u0026lt;\u0026lt; std::endl; } else { return r.as_failure(); // #5  } } return outcome::success(); // #6 } View this code on Github #1. You test if result\u0026lt;\u0026gt; object represents a successful operation with contextual conversion to bool.\n#2. The function .value() extracts the successfully returned int.\n#3. The function .error() allows you to inspect the error sub-object, representing information about the reason for failure.\n#4. Macro OUTCOME_TRY represents a control statement. It implies that the expression in the second argument returns a result\u0026lt;\u0026gt;. The function is defined as:\n/*static*/ outcome::result\u0026lt;BigInt\u0026gt; BigInt::fromString(const std::string\u0026amp; s) View this code on Github Our control statement means: if fromString returned failure, this same error information should be returned from print_half, even though the type of result\u0026lt;\u0026gt; is different. If fromString returned success, we create variable i of type BigInt with the value returned from fromString. If control goes to subsequent line, it means fromString succeeded and variable of type BigInt is in scope.\n#5. In the return statement we extract the error information and use it to initialize the return value from print_half. We could have written return r.error(); instead, and it would have the same effect, but r.as_failure() will work when implicit construction from E has been disabled due to T and E having a constructibility relationship.\n#6. Function success() returns an object of type success\u0026lt;void\u0026gt; representing success. This is implicitly converted by all result and outcome types into a successful return, default constructing any T if necessary.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/filelib/",
	"title": "The File I/O library",
	"tags": [],
	"description": "",
	"content": "The File I/O library we shall be using is very similar to the one we saw earlier in this tutorial:\n// You may remember this from the tutorial section on Custom Payloads namespace filelib { // Error code + paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { std::error_code ec; path path1{}, path2{}; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code \u0026amp;make_error_code(const failure_info \u0026amp;fi) { return fi.ec; } // Tell Outcome that no-value observation should throw a custom exception  inline void outcome_throw_as_system_error_with_payload(failure_info fi) { // If the error code is not filesystem related e.g. ENOMEM, throw that as a standard STL exception.  OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(fi.ec); // Throw the exact same filesystem_error exception which the throwing copy_file() edition does.  throw filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec); } // Localise a result implementation specific to this namespace.  template \u0026lt;class T\u0026gt; using result = OUTCOME_V2_NAMESPACE::result\u0026lt;T, failure_info\u0026gt;; // Writes a chunk of data to some file. Returns bytes written, or failure_info. Never throws exceptions.  result\u0026lt;size_t\u0026gt; write_file(string_view chunk) noexcept; } View this code on Github This uses the advanced Outcome feature of programming the lazy synthesis of custom C++ exception throws from a payload carrying E type called failure_info. Like the HTTP library, it too template aliases a localised result implementation into its namespace with ADL bridging so Outcome customisation points can be discovered.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/payload/copy_file2/",
	"title": "Upgrading the Filesystem TS",
	"tags": ["payload"],
	"description": "",
	"content": "An Outcome based solution to the dual overload problem is straightforward:\nnamespace filesystem2 { // Error code + paths related to a failure. Also causes ADL discovery to check this namespace.  struct failure_info { std::error_code ec; path path1, path2; }; // Tell Outcome that failure_info is to be treated as a std::error_code  inline const std::error_code \u0026amp;make_error_code(const failure_info \u0026amp;fi) { return fi.ec; } // Localise an outcome implementation specific to this namespace. Normally would just  // be `result`, but for clarity we\u0026#39;ll use `fs_result`.  template \u0026lt;class T\u0026gt; using fs_result = outcome::result\u0026lt;T, failure_info\u0026gt;; /*! Copies the file at path `from` to path `to`. \\returns Successful if file was successfully copied, otherwise the error code reported by the operating system plus a payload of the paths involved. \\throws Never throws. */ fs_result\u0026lt;void\u0026gt; copy_file(const path \u0026amp;from, const path \u0026amp;to) noexcept; } View this code on Github Starting at the bottom, there is now a single copy_file() function which returns a fs_result\u0026lt;void\u0026gt;. As result is either successful or not, there is no longer any point in returning a boolean, so we simply return void on success. On failure, as the template alias fs_result\u0026lt;T\u0026gt; above it shows, we are returning a failure_info structure containing an error code and the same additional information as filesystem_error provides.\nIt is important to note that the fact that failure_info is defined in namespace filesystem2 is very important. This is because Outcome uses Argument Dependent Lookup (ADL) to find the make_error_code() function, as well as other customisation point free functions. In other words, only the namespaces as defined by ADL are searched when finding a free function telling us what to do for failure_info, which includes the namespace failure_info is declared into.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/outcome_error_code_throw_as_system_error/",
	"title": "error_code throw as system_error (Outcome)",
	"tags": [],
	"description": "",
	"content": " Header file outcome_error_code_throw_as_system_error.hpp \n#include\u0026nbsp;\u0026quot;result_error_code_throw_as_system_error.hpp\u0026quot; namespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace\u0026nbsp;policy \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct error_code_throw_as_system_error; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} }  \n\nStruct outcome_v2_xxx::policy::error_code_throw_as_system_error \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; struct\u0026nbsp;error_code_throw_as_system_error { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; };  Policy interpreting EC as a type for which trait::has_error_code_v\u0026lt;EC\u0026gt; is true.\nAny wide attempt to access the successful state where there is none causes an attempt to rethrow E if trait::has_exception_ptr_v\u0026lt;E\u0026gt; is true, else:\n If trait::has_error_payload_v\u0026lt;EC\u0026gt; is true, it calls an ADL discovered free function throw_as_system_error_with_payload(.error()).\n If trait::has_error_payload_v\u0026lt;EC\u0026gt; is false, it calls OUTCOME_THROW_EXCEPTION(std::system_error(policy::error_code(.error())))\n  Function outcome_v2_xxx::policy::throw_bad_result_access::narrow_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::error_code_throw_as_system_error::wide_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the value() functions.\nEffects: See description of class for effects.\nFunction outcome_v2_xxx::policy::error_code_throw_as_system_error::wide_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_outcome_access.\nFunction outcome_v2_xxx::policy::error_code_throw_as_system_error::wide_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the exception() functions\nEffects: If result does not have an exception, it throws bad_outcome_access.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/outcome/",
	"title": "outcome&lt;T, EC, EP&gt;",
	"tags": ["outcome"],
	"description": "Success-or-failure return types where failure can take two forms, expected/handled failure and unexpected/abort failure.",
	"content": " outcome\u0026lt;\u0026gt; Type  outcome\u0026lt;T, EC, EP\u0026gt; represets either a successfully computed value of type T or a reason for failure. Failure can be represented by EC or EP or both. Although usually it will either be an EC or an EP. EC defaults to std::error_code and EP defaults to std::exception_ptr. The distinction is made into two types, EC and EP:\n EC represents a failue from lower-layer function which was retured through  result\u0026lt;T, EC\u0026gt; . EP represents pointer to an exception thrown in a lower-layer function to signal a failure; but at the current level we do not want to proceed with stack unwinding.  outcome\u0026lt;T, EC, EP\u0026gt; is useful for transporting exceptions across layers of the program that were never designed with exception safety in mind.\nConsider a program consisting of three layers:\ngraph BT L3[\"Layer3\"] L2[\"Layer2_old\"] -- L3 L1[\"Layer1\"] -- L2  The highest-level layer, Layer3, uses exceptions for signalling failures. The middle layer, Layer2_old, was not designed with exception safety in mind and functions need to return information about failures in return value. But down in the implementation details, in Layer1, another library is used that again throws exceptions. The goal is to be able to transfer an exception thrown in Layer1 through Layer2_old, which is not exception-safe, and be able to rethrow it in Layer3.\nIn Layer1 we have two functions from two libraries: one reports failures by throwing exceptions, the other by returning result\u0026lt;\u0026gt;:\nauto f() -\u0026gt; int; // throws on failure auto g() noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;; View this code on Github In Layer2_old we cannot use exceptions, so its function h uses return type outcome\u0026lt;\u0026gt; to report failures. It is using functions f and g and reports their failures inside outcome\u0026lt;\u0026gt;:\nauto old::h() noexcept -\u0026gt; outcome::outcome\u0026lt;int\u0026gt; { OUTCOME_TRY(i, (g())); // #1  try { return i + f(); } catch (...) { return std::current_exception(); // #2  } } View this code on Github #1. Operator TRY can forward failures encoded in result\u0026lt;T, EC\u0026gt; as outcome\u0026lt;T, EC, EP\u0026gt; without any loss in information. You can also use TRY to forward failure from one outcome\u0026lt;\u0026gt; to another.\n#2. You can store the current exception through std::exception_ptr inside outcome\u0026lt;T, EC, EP\u0026gt; without any loss in information (provided that EP is std::exception_ptr).\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/result/",
	"title": "result&lt;R, S&gt;",
	"tags": [],
	"description": "",
	"content": " Header file result.hpp \nnamespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace policy \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using default_policy\u0026nbsp;=\u0026nbsp;std::conditional_t\u0026lt;std::is_void\u0026lt;EC\u0026gt;::value \u0026amp;\u0026amp; std::is_void\u0026lt;E\u0026gt;::value, terminate, std::conditional_t\u0026lt;trait::has_error_code_v\u0026lt;EC\u0026gt;, error_code_throw_as_system_error\u0026lt;T, EC, E\u0026gt;, std::conditional_t\u0026lt;trait::has_exception_ptr_v\u0026lt;EC\u0026gt; || trait::has_exception_ptr_v\u0026lt;E\u0026gt;, exception_ptr_rethrow\u0026lt;T, EC, E\u0026gt;, all_narrow\u0026gt; \u0026gt;\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using is_result\u0026nbsp;=\u0026nbsp;\u0026#x27;hidden\u0026#x27;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;is_result_v\u0026nbsp;=\u0026nbsp;detail::is_result\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace hooks \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void hook_result_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void hook_result_copy_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void hook_result_move_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void hook_result_in_place_construction(T*, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;NoValuePolicy\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;uint16_t spare_storage(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const*\u0026nbsp;r)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;NoValuePolicy\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void set_spare_storage(\u0026#x27;hidden\u0026#x27;*\u0026nbsp;r,\u0026nbsp;uint16_t\u0026nbsp;v)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class R,\u0026nbsp;class S,\u0026nbsp;class NoValuePolicy\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;class result; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;void swap(result\u0026lt;R, S, P\u0026gt;\u0026amp;\u0026nbsp;a, result\u0026lt;R, S, P\u0026gt;\u0026amp;\u0026nbsp;b)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;is_result_v\u0026nbsp;=\u0026nbsp;detail::is_result\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;is_result_v\u0026nbsp;=\u0026nbsp;detail::is_result\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S\u0026nbsp;= std::error_code\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using unchecked\u0026nbsp;= result\u0026lt;R, S, policy::all_narrow\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S\u0026nbsp;= std::error_code\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using checked\u0026nbsp;= result\u0026lt;R, S, policy::throw_bad_result_access\u0026lt;S\u0026gt;\u0026gt;; }  \n\nAlias template outcome_v2_xxx::policy::default_policy \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; using\u0026nbsp;default_policy\u0026nbsp;=\u0026nbsp;std::conditional_t\u0026lt;std::is_void\u0026lt;EC\u0026gt;::value \u0026amp;\u0026amp; std::is_void\u0026lt;E\u0026gt;::value, terminate, std::conditional_t\u0026lt;trait::has_error_code_v\u0026lt;EC\u0026gt;, error_code_throw_as_system_error\u0026lt;T, EC, E\u0026gt;, std::conditional_t\u0026lt;trait::has_exception_ptr_v\u0026lt;EC\u0026gt; || trait::has_exception_ptr_v\u0026lt;E\u0026gt;, exception_ptr_rethrow\u0026lt;T, EC, E\u0026gt;, all_narrow\u0026gt; \u0026gt;\u0026gt;;  Default policy selector.\nAlias template outcome_v2_xxx::is_result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; using\u0026nbsp;is_result\u0026nbsp;=\u0026nbsp;\u0026#x27;hidden\u0026#x27;;  True if a result\nUnexposed entity outcome_v2_xxx::is_result_v \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;is_result_v\u0026nbsp;=\u0026nbsp;detail::is_result\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;::value;  True if a result\n\nFunction outcome_v2_xxx::hooks::hook_result_construction \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;hook_result_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept;  The default instantiation hook implementation called when a result is first created by conversion from one of its possible types. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters   \u0026mdash; Some result\u0026lt;...\u0026gt; being constructed.  Function outcome_v2_xxx::hooks::hook_result_copy_construction \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;hook_result_copy_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept;  The default instantiation hook implementation called when a result is created by copying from another result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters   \u0026mdash; Some result\u0026lt;...\u0026gt; being constructed.  Function outcome_v2_xxx::hooks::hook_result_move_construction \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;hook_result_move_construction(T*,\u0026nbsp;U\u0026amp;\u0026amp;)\u0026nbsp;noexcept;  The default instantiation hook implementation called when a result is created by moving from another result. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters   \u0026mdash; Some result\u0026lt;...\u0026gt; being constructed.  Function outcome_v2_xxx::hooks::hook_result_in_place_construction \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;hook_result_in_place_construction(T*, in_place_type_t\u0026lt;U\u0026gt;, Args \u0026amp;\u0026amp;...)\u0026nbsp;noexcept;  The default instantiation hook implementation called when a result is created by in place construction. Does nothing.\nWARNING: The compiler is permitted to elide calls to constructors, and thus this hook may not get called when you think it should!\nParameters   \u0026mdash; Some result\u0026lt;...\u0026gt; being constructed.  \u0026mdash; The type of in place construction occurring.  Function outcome_v2_xxx::hooks::spare_storage \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;NoValuePolicy\u0026gt; constexpr\u0026nbsp;uint16_t\u0026nbsp;spare_storage(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const*\u0026nbsp;r)\u0026nbsp;noexcept;  Retrieves the 16 bits of spare storage in result/outcome.\nFunction outcome_v2_xxx::hooks::set_spare_storage \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;NoValuePolicy\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;set_spare_storage(\u0026#x27;hidden\u0026#x27;*\u0026nbsp;r,\u0026nbsp;uint16_t\u0026nbsp;v)\u0026nbsp;noexcept;  Sets the 16 bits of spare storage in result/outcome.\nClass outcome_v2_xxx::result \ntemplate\u0026nbsp;\u0026lt;class R,\u0026nbsp;class S,\u0026nbsp;class NoValuePolicy\u0026gt; class\u0026nbsp;result { public: \u0026#x2F;\u0026#x2F;=== Member types ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using value_type\u0026nbsp;= R; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using error_type\u0026nbsp;= S; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using value_type_if_enabled\u0026nbsp;= typename base::_value_type; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using error_type_if_enabled\u0026nbsp;= typename base::_error_type; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026nbsp;= S,\u0026nbsp;class\u0026nbsp;V\u0026nbsp;= policy::default_policy\u0026lt;T,U,void\u0026gt;\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using rebind\u0026nbsp;=\u0026nbsp;result\u0026lt;T, U, V\u0026gt;; protected: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct predicate; public: \u0026#x2F;\u0026#x2F;=== Default, copy\u0026#x2F;move constructors and assignment ===\u0026#x2F;\u0026#x2F; result()\u0026nbsp;=\u0026nbsp;delete; result(result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; result(const result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp; operator=(result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp; operator=(const result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;~result()\u0026nbsp;=\u0026nbsp;default; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;ErrorCondEnum\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(ErrorCondEnum\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(T\u0026amp;\u0026amp; o); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(in_place_type_t\u0026lt;outcome_v2_xxx::result::value_type_if_enabled\u0026gt; _, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(in_place_type_t\u0026lt;outcome_v2_xxx::result::value_type_if_enabled\u0026gt; _,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(in_place_type_t\u0026lt;outcome_v2_xxx::result::error_type_if_enabled\u0026gt; _, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(in_place_type_t\u0026lt;outcome_v2_xxx::result::error_type_if_enabled\u0026gt; _,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;A1,\u0026nbsp;class\u0026nbsp;A2,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(A1\u0026amp;\u0026amp;\u0026nbsp;a1,\u0026nbsp;A2\u0026amp;\u0026amp;\u0026nbsp;a2, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(success_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(failure_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr result(failure_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;void swap(result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;\u0026nbsp;o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;auto as_failure()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;auto as_failure()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using\u0026nbsp;error_type\u0026nbsp;=\u0026nbsp;\u0026#x27;hidden\u0026#x27;; \u0026#x2F;\u0026#x2F;=== assume_error ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp; assume_error()\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp; assume_error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp; assume_error()\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp; assume_error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept; \u0026#x2F;\u0026#x2F;=== error ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp; error()\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp; error()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;explicit\u0026nbsp;operator\u0026nbsp;bool()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool has_value()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool has_error()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool has_exception()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool has_failure()\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator==(failure_type\u0026lt;T, void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;bool operator!=(failure_type\u0026lt;T, void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;); };  Used to return from functions either (i) a successful value (ii) a cause of failure. constexpr capable.\nAny R (value_type) state can be observed using the member functions .value() and .assume_value(). Any S (error_type) state can be observed using the member functions .error() and .assume_error().\nNoValuePolicy defaults to a policy selected according to the characteristics of type S:\n If .value() called when there is no value_type but there is an error_type:\n If  trait::has_error_code_v\u0026lt;S\u0026gt; is true, then throw std::system_error(error()|make_error_code(error())) [ policy::error_code_throw_as_system_error\u0026lt;S\u0026gt; ]\n If  trait::has_exception_ptr_v\u0026lt;S\u0026gt; is true, then std::rethrow_exception(error()|make_exception_ptr(error())) [ policy::exception_ptr_rethrow\u0026lt;R, S, void\u0026gt; ]\n If S is void, call std::terminate() [ policy::terminate ]\n If S is none of the above, then it is undefined behaviour [ policy::all_narrow ]\n  If .error() called when there is no error_type:\n If trait::has_error_code_v\u0026lt;S\u0026gt;, or if trait::has_exception_ptr_v\u0026lt;S\u0026gt;, or if S is void, do throw bad_result_access()\n If S is none of the above, then it is undefined behaviour [policy::all_narrow]\n   Template parameters  R \u0026mdash; The optional type of the successful result (use void to disable). Cannot be a reference, a in_place_type_t\u0026lt;\u0026gt;, success\u0026lt;\u0026gt;, failure\u0026lt;\u0026gt;, an array, a function or non-destructible. S \u0026mdash; The optional type of the failure result (use void to disable). Must be either void or DefaultConstructible. Cannot be a reference, a in_place_type_t\u0026lt;\u0026gt;, success\u0026lt;\u0026gt;, failure\u0026lt;\u0026gt;, an array, a function or non-destructible. NoValuePolicy \u0026mdash; Policy on how to interpret type S when a wide observation of a not present value occurs.  Function outcome_v2_xxx::outcome::assume_error \n(1)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026nbsp;assume_error()\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; (2)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026nbsp;assume_error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026nbsp;noexcept; (3)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp;\u0026nbsp;assume_error()\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept; (4)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp;\u0026nbsp;assume_error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;noexcept;  Access error without runtime checks.\nPreconditions: The result to have a failed state, otherwise it is undefined behaviour.\nReturns: Reference to the held error_type according to overload.\nFunction outcome_v2_xxx::outcome::error \n(1)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;; (2)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;; (3)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;\u0026amp;; (4)\u0026nbsp;constexpr\u0026nbsp;error_type\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;;  Access error with runtime checks.\nReturns: Reference to the held error_type according to overload.\nRequires: The result to have a failed state, else whatever NoValuePolicy says ought to happen.\nConversion operator outcome_v2_xxx::outcome::operator bool \nexplicit\u0026nbsp;operator\u0026nbsp;bool()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has value.\nReturns: True if has value.\nFunction outcome_v2_xxx::outcome::has_value \nconstexpr\u0026nbsp;bool\u0026nbsp;has_value()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has value.\nReturns: True if has value.\nFunction outcome_v2_xxx::outcome::has_error \nconstexpr\u0026nbsp;bool\u0026nbsp;has_error()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has error.\nReturns: True if has error.\nFunction outcome_v2_xxx::outcome::has_exception \nconstexpr\u0026nbsp;bool\u0026nbsp;has_exception()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has exception.\nReturns: True if has exception.\nFunction outcome_v2_xxx::outcome::has_failure \nconstexpr\u0026nbsp;bool\u0026nbsp;has_failure()\u0026nbsp;const\u0026nbsp;noexcept;  Checks if has error or exception.\nReturns: True if has error or exception.\nFunction outcome_v2_xxx::outcome::operator== \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator==(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if equal to the other result.\nEffects: If a valid expression to do so, calls the operator== operation on each of the two stored items returning true if both are true. Otherwise returns false.\nThrows: Any exception the individual operator== operations might throw.\nParameters  o \u0026mdash; The other result to compare to.  Function outcome_v2_xxx::outcome::operator== \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator==(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if equal to the success type sugar.\nEffects: If a valid expression to do so, calls the operator== operation on the successful item returning true if equal. Otherwise returns false.\nThrows: Any exception the operator== operation might throw.\nParameters  o \u0026mdash; The success type sugar to compare to.  Function outcome_v2_xxx::outcome::operator== \nconstexpr\u0026nbsp;bool\u0026nbsp;operator==(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept;  True if equal to the success type sugar.\nEffects: If a valid expression to do so, calls the operator== operation on the successful item returning true if equal. Otherwise returns false.\nThrows: Any exception the operator== operation might throw.\nParameters  o \u0026mdash; The success type sugar to compare to.  Function outcome_v2_xxx::outcome::operator== \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator==(failure_type\u0026lt;T, void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if equal to the failure type sugar.\nEffects: If a valid expression to do so, calls the operator== operation on the failure item returning true if equal. Otherwise returns false.\nThrows: Any exception the operator== operation might throw.\nParameters  o \u0026mdash; The failure type sugar to compare to.  Function outcome_v2_xxx::outcome::operator!= \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator!=(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if not equal to the other result.\nEffects: If a valid expression to do so, calls the operator!= operation on each of the two stored items, returning true if any are not equal. Otherwise returns true.\nThrows: Any exception the individual operator!= operations might throw.\nParameters  o \u0026mdash; The other result to compare to.  Function outcome_v2_xxx::outcome::operator!= \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator!=(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if not equal to the success type sugar.\nEffects: If a valid expression to do so, calls the operator!= operation on the successful item returning true if not equal. Otherwise returns false.\nThrows: Any exception the operator!= operation might throw.\nParameters  o \u0026mdash; The success type sugar to compare to.  Function outcome_v2_xxx::outcome::operator!= \nconstexpr\u0026nbsp;bool\u0026nbsp;operator!=(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept;  True if not equal to the success type sugar.\nEffects: If a valid expression to do so, calls the operator!= operation on the successful item returning true if not equal. Otherwise returns false.\nThrows: Any exception the operator!= operation might throw.\nParameters  o \u0026mdash; The success type sugar to compare to.  Function outcome_v2_xxx::outcome::operator!= \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;bool\u0026nbsp;operator!=(failure_type\u0026lt;T, void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;const\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  True if not equal to the failure type sugar.\nEffects: If a valid expression to do so, calls the operator!= operation on the failure item returning true if not equal. Otherwise returns false.\nThrows: Any exception the operator!= operation might throw.\nParameters  o \u0026mdash; The failure type sugar to compare to.  Type alias outcome_v2_xxx::result::value_type \nusing\u0026nbsp;value_type\u0026nbsp;= R;  The success type.\nType alias outcome_v2_xxx::result::error_type \nusing\u0026nbsp;error_type\u0026nbsp;= S;  The failure type.\nType alias outcome_v2_xxx::result::value_type_if_enabled \nusing\u0026nbsp;value_type_if_enabled\u0026nbsp;= typename base::_value_type;  Used to disable in place type construction when value_type and error_type are ambiguous.\nType alias outcome_v2_xxx::result::error_type_if_enabled \nusing\u0026nbsp;error_type_if_enabled\u0026nbsp;= typename base::_error_type;  Used to disable in place type construction when value_type and error_type are ambiguous.\nAlias template outcome_v2_xxx::result::rebind \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026nbsp;= S,\u0026nbsp;class\u0026nbsp;V\u0026nbsp;= policy::default_policy\u0026lt;T,U,void\u0026gt;\u0026gt; using\u0026nbsp;rebind\u0026nbsp;= result\u0026lt;T, U, V\u0026gt;;  Used to rebind this result to a different result type.\nStruct outcome_v2_xxx::result::predicate \nstruct\u0026nbsp;predicate { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using\u0026nbsp;base\u0026nbsp;=\u0026nbsp;\u0026#x27;hidden\u0026#x27;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_value_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;T\u0026gt;,\u0026nbsp;result\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_value_converting_constructor\u0026lt;T\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_error_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;T\u0026gt;,\u0026nbsp;result\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_error_converting_constructor\u0026lt;T\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;ErrorCondEnum\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_error_condition_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;ErrorCondEnum\u0026gt;,\u0026nbsp;result\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_compatible_conversion\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;result\u0026lt;T,\u0026nbsp;U,\u0026nbsp;V\u0026gt;,\u0026nbsp;result\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_compatible_conversion\u0026lt;T,\u0026nbsp;U,\u0026nbsp;V\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_value_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;value_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;value_type,\u0026nbsp;Args...\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_error_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;error_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;error_type,\u0026nbsp;Args...\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_value_error_constructor\u0026nbsp;=\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_inplace_value_error_constructor\u0026lt;Args...\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using\u0026nbsp;choose_inplace_value_error_constructor\u0026nbsp;= typename base::choose_inplace_value_error_constructor\u0026lt;Args...\u0026gt;; };  Requirement predicates for result.\nUnexposed entity outcome_v2_xxx::result::predicate::enable_value_converting_constructor \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_value_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;T\u0026gt;,\u0026nbsp;result\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_value_converting_constructor\u0026lt;T\u0026gt;;  Predicate for the value converting constructor to be available.\nUnexposed entity outcome_v2_xxx::result::predicate::enable_error_converting_constructor \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_error_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;T\u0026gt;,\u0026nbsp;result\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_error_converting_constructor\u0026lt;T\u0026gt;;  Predicate for the error converting constructor to be available.\nUnexposed entity outcome_v2_xxx::result::predicate::enable_error_condition_converting_constructor \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;ErrorCondEnum\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_error_condition_converting_constructor\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;std::decay_t\u0026lt;ErrorCondEnum\u0026gt;,\u0026nbsp;result\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_error_condition_converting_constructor\u0026lt;ErrorCondEnum\u0026gt;;  Predicate for the error condition converting constructor to be available.\nUnexposed entity outcome_v2_xxx::result::predicate::enable_compatible_conversion \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_compatible_conversion\u0026nbsp;=\u0026nbsp;!std::is_same\u0026lt;result\u0026lt;T,\u0026nbsp;U,\u0026nbsp;V\u0026gt;,\u0026nbsp;result\u0026gt;::value\u0026nbsp;\u0026amp;\u0026amp;\u0026nbsp;base::template\u0026nbsp;\u0026nbsp;enable_compatible_conversion\u0026lt;T,\u0026nbsp;U,\u0026nbsp;V\u0026gt;;  Predicate for the converting copy constructor from a compatible input to be available.\nUnexposed entity outcome_v2_xxx::result::predicate::enable_inplace_value_constructor \ntemplate\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_value_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;value_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;value_type,\u0026nbsp;Args...\u0026gt;::value;  Predicate for the inplace construction of value to be available.\nUnexposed entity outcome_v2_xxx::result::predicate::enable_inplace_error_constructor \ntemplate\u0026nbsp;\u0026lt;class...Args\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;enable_inplace_error_constructor\u0026nbsp;=\u0026nbsp;std::is_void\u0026lt;error_type\u0026gt;::value\u0026nbsp;||\u0026nbsp;std::is_constructible\u0026lt;error_type,\u0026nbsp;Args...\u0026gt;::value;  Predicate for the inplace construction of error to be available.\nConstructor outcome_v2_xxx::result::result \nresult()\u0026nbsp;=\u0026nbsp;delete;  Default construction is not permitted.\nConstructor outcome_v2_xxx::result::result \nresult(result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move construction available if value_type and error_type implement it.\nConstructor outcome_v2_xxx::result::result \nresult(const result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy construction available if value_type and error_type implement it.\nFunction outcome_v2_xxx::result::operator= \nresult\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;\u0026nbsp;operator=(result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move assignment available if value_type and error_type implement it.\nFunction outcome_v2_xxx::result::operator= \nresult\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;\u0026nbsp;operator=(const result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy assignment available if value_type and error_type implement it.\nConstructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;result(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit converting constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: Type T is implicitly constructible to value_type, is not implicitly constructible to error_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters  t \u0026mdash; The value from which to initialise the value_type.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;result(T\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit converting constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: Type T is implicitly constructible to error_type, is not implicitly constructible to value_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters  t \u0026mdash; The value from which to initialise the error_type.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;ErrorCondEnum\u0026gt; constexpr\u0026nbsp;result(ErrorCondEnum\u0026amp;\u0026amp; t)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit special error condition converting constructor to a failure result.\nEffects: Initialises the result with a error_type constructed via make_error_code(t).\nRequires: std::is_error_condition_enum\u0026lt;ErrorCondEnum\u0026gt; must be true, ErrorCondEnum is not implicitly constructible to value_type nor error_type, and is not result\u0026lt;R, S\u0026gt; and not in_place_type\u0026lt;\u0026gt;; Finally, the expression error_type(make_error_code(ErrorCondEnum())) must be valid.\nThrows: Any exception the construction of error_type(make_error_code(t)) might throw.\nParameters  t \u0026mdash; The error condition from which to initialise the error_type.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;result(T\u0026amp;\u0026amp; o);  Explicit converting constructor from a compatible ValueOrError type.\nEffects: Initialises the result with the contents of the compatible input.\nRequires: That convert::value_or_error\u0026lt;result, std::decay_t\u0026lt;T\u0026gt;\u0026gt;{}(std::forward\u0026lt;T\u0026gt;(o)) be available. The default implementation will consume T‚Äôs matching the ValueOrError concept type. ValueOrError concept matches any type with a value_type, an error_type, a .value(), an .error() and a .has_value().\nParameters  o \u0026mdash; The input for which a convert::value_or_error\u0026lt;result, std::decay_t\u0026lt;T\u0026gt;\u0026gt;{}(std::forward\u0026lt;T\u0026gt;(o)) is available.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; constexpr\u0026nbsp;result(result\u0026lt;T, U, V\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit converting copy constructor from a compatible result type.\nEffects: Initialises the result with a copy of the compatible result.\nRequires: Both result‚Äôs value_type and error_type need to be constructible, or the source can be void.\nThrows: Any exception the construction of value_type(T) and error_type(U) might throw.\nParameters  o \u0026mdash; The compatible result.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; constexpr\u0026nbsp;result(result\u0026lt;T, U, V\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit converting move constructor from a compatible result type.\nEffects: Initialises the result with a move of the compatible result.\nRequires: Both result‚Äôs value_type and error_type need to be constructible, or the source can be void.\nThrows: Any exception the construction of value_type(T) and error_type(U) might throw.\nParameters  o \u0026mdash; The compatible result.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;result(in_place_type_t\u0026lt;outcome_v2_xxx::result::value_type_if_enabled\u0026gt; _, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: value_type is void or Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(Args...) might throw.\nParameters  _ \u0026mdash; Tag type to indicate we are doing in place construction of value_type. args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;result(in_place_type_t\u0026lt;outcome_v2_xxx::result::value_type_if_enabled\u0026gt; _,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit inplace constructor to a successful result.\nEffects: Initialises the result with a value_type.\nRequires: The initializer list + Args... are constructible to value_type.\nThrows: Any exception the construction of value_type(il, Args...) might throw.\nParameters  _ \u0026mdash; Tag type to indicate we are doing in place construction of value_type. il \u0026mdash; An initializer list with which to in place construct. args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;result(in_place_type_t\u0026lt;outcome_v2_xxx::result::error_type_if_enabled\u0026gt; _, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: error_type is void or Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(Args...) might throw.\nParameters  _ \u0026mdash; Tag type to indicate we are doing in place construction of error_type. args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;result(in_place_type_t\u0026lt;outcome_v2_xxx::result::error_type_if_enabled\u0026gt; _,\u0026nbsp;std::initializer_list\u0026lt;U\u0026gt; il, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Explicit inplace constructor to a failure result.\nEffects: Initialises the result with a error_type.\nRequires: The initializer list + Args... are constructible to error_type.\nThrows: Any exception the construction of error_type(il, Args...) might throw.\nParameters  _ \u0026mdash; Tag type to indicate we are doing in place construction of error_type. il \u0026mdash; An initializer list with which to in place construct. args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;A1,\u0026nbsp;class\u0026nbsp;A2,\u0026nbsp;class\u0026nbsp;...\u0026nbsp;Args\u0026gt; constexpr\u0026nbsp;result(A1\u0026amp;\u0026amp;\u0026nbsp;a1,\u0026nbsp;A2\u0026amp;\u0026amp;\u0026nbsp;a2, Args \u0026amp;\u0026amp;... args)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit inplace constructor to successful or failure result.\nEffects: Calls the appropriate in_place_type_t\u0026lt;...\u0026gt; constructor depending on constructibility of args.\nRequires: That the args can construct exactly one of value_type or error_type.\nThrows: Any exception the in_place_type_t\u0026lt;...\u0026gt; constructor might throw.\nParameters  args \u0026mdash; Arguments with which to in place construct.  Constructor outcome_v2_xxx::result::result \nconstexpr\u0026nbsp;result(success_type\u0026lt;void\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a successful result.\nEffects: Initialises the result with a default constructed success type.\nRequires: value_type to be default constructible, or void.\nThrows: Any exception the construction of value_type() might throw.\nParameters  o \u0026mdash; The compatible success type sugar.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;result(success_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a successful result.\nEffects: Initialises the result with a copy of the value in the type sugar.\nRequires: Both result and success‚Äô value_type need to be constructible, or the source can be void.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters  o \u0026mdash; The compatible success type sugar.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;result(success_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a successful result.\nEffects: Initialises the result with a move of the value in the type sugar.\nRequires: Both result and success‚Äô value_type need to be constructible. The source cannot be void.\nThrows: Any exception the construction of value_type(T) might throw.\nParameters  o \u0026mdash; The compatible success type sugar.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;result(failure_type\u0026lt;T\u0026gt;\u0026nbsp;const\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a failure result.\nEffects: Initialises the result with a copy of the error in the type sugar.\nRequires: Both result and failure‚Äôs error_type need to be constructible, or the source can be void.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters  o \u0026mdash; The compatible failure type sugar.  Constructor outcome_v2_xxx::result::result \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;result(failure_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp; o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Implicit tagged constructor of a failure result.\nEffects: Initialises the result with a move of the error in the type sugar.\nRequires: Both result and failure‚Äôs error_type need to be constructible, or the source can be void.\nThrows: Any exception the construction of error_type(T) might throw.\nParameters  o \u0026mdash; The compatible failure type sugar.  Function outcome_v2_xxx::result::swap \nvoid\u0026nbsp;swap(result\u0026lt;R, S, NoValuePolicy\u0026gt;\u0026amp;\u0026nbsp;o)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Swaps this result with another result\nEffects: Any R and/or S is swapped along with the metadata tracking them.\nFunction outcome_v2_xxx::result::as_failure \nauto\u0026nbsp;as_failure()\u0026nbsp;const\u0026nbsp;\u0026amp;;  Returns this result as a failure_type with any errored state copied.\nRequires: This result to have a failed state, else whatever assume_error() would do.\nFunction outcome_v2_xxx::result::as_failure \nauto\u0026nbsp;as_failure()\u0026nbsp;\u0026amp;\u0026amp;;  Returns this result as a failure_type with any errored state moved.\nRequires: This result to have a failed state, else whatever assume_error() would do.\nFunction outcome_v2_xxx::swap \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; void\u0026nbsp;swap(result\u0026lt;R, S, P\u0026gt;\u0026amp;\u0026nbsp;a, result\u0026lt;R, S, P\u0026gt;\u0026amp;\u0026nbsp;b)\u0026nbsp;noexcept(\u0026#x27;hidden\u0026#x27;);  Specialise swap for result.\nEffects: Calls a.swap(b).\nAlias template outcome_v2_xxx::unchecked \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S\u0026nbsp;= std::error_code\u0026gt; using\u0026nbsp;unchecked\u0026nbsp;= result\u0026lt;R, S, policy::all_narrow\u0026gt;;  An ‚Äúunchecked‚Äù edition of result\u0026lt;T, E\u0026gt; which does no special handling of specific E types at all.\nAttempting to access T when there is an E results in nothing happening at all, it is treated with a narrow contract (i.e. undefined behaviour).\nAlias template outcome_v2_xxx::checked \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S\u0026nbsp;= std::error_code\u0026gt; using\u0026nbsp;checked\u0026nbsp;= result\u0026lt;R, S, policy::throw_bad_result_access\u0026lt;S\u0026gt;\u0026gt;;  A ‚Äúchecked‚Äù edition of result\u0026lt;T, E\u0026gt; which resembles fairly closely a std::expected\u0026lt;T, E\u0026gt;.\nAttempting to access T when there is an E results in bad_result_access\u0026lt;E\u0026gt; being thrown. Nothing else.\nNote that this approximates the proposed expected\u0026lt;T, E\u0026gt; up for standardisation, see the FAQ for more detail.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/happens2/",
	"title": "-- What happens?",
	"tags": ["undefined-behaviour"],
	"description": "",
	"content": "Let us run the code from the previous page:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_error_code_enums1 Segmentation fault (core dumped) ned@lyta:~/outcome/build_posix$  Also undefined behaviour. This is because Outcome doesn\u0026rsquo;t know what to do with a strongly typed enum any more than some user defined struct.\nLet us register our error code enum with the C++ standard library. This causes Outcome to treat it quite differently.\nstruct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; enum class err { success, failure1, failure2 }; // Tell the standard library that enum err is an error code enum // by specialising the is_error_code_enum trait. See // http://en.cppreference.com/w/cpp/error/error_code/is_error_code_enum namespace std { template \u0026lt;\u0026gt; struct is_error_code_enum\u0026lt;err\u0026gt; : std::true_type { }; } // We also must declare a free function make_error_code. This is // discovered via ADL by the standard library. See // http://en.cppreference.com/w/cpp/error/errc/make_error_code inline std::error_code make_error_code(err c) { // We need to inherit from std::error_category to define  // an error code domain with the standard library for  // our strongly typed enum. See  // http://en.cppreference.com/w/cpp/error/error_category  static struct err_category : std::error_category { virtual const char *name() const noexcept override final { return \u0026#34;err_category\u0026#34;; }; virtual std::string message(int c) const override final { switch(static_cast\u0026lt;err\u0026gt;(c)) { case err::success: return \u0026#34;err::success\u0026#34;; case err::failure1: return \u0026#34;err::failure1\u0026#34;; case err::failure2: return \u0026#34;err::failure2\u0026#34;; } return \u0026#34;unknown\u0026#34;; } } category; return std::error_code(static_cast\u0026lt;int\u0026gt;(c), category); } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app/",
	"title": "The Application",
	"tags": [],
	"description": "",
	"content": "The application is of course also based on Outcome, and like the HTTP library is also of mixed-failure design in that failure can be returned via error code, type erased exception_ptr or indeed a C++ exception throw.\n// This is the namespace of the application which is connecting together the httplib, // filelib and tidylib libraries into a solution. namespace app { // Create an ADL bridge so copy/move hooks will be searched for in this namespace  struct error_code : public std::error_code { // passthrough  using std::error_code::error_code; error_code() = default; error_code(std::error_code ec) : std::error_code(ec) { } }; // Localise an outcome implementation for this namespace  template \u0026lt;class T\u0026gt; using outcome = OUTCOME_V2_NAMESPACE::outcome\u0026lt;T, error_code /*, std::exception_ptr */\u0026gt;; using OUTCOME_V2_NAMESPACE::success; } View this code on Github Here we localise a passthrough error_code solely for the purpose of ADL bridging, otherwise the localised outcome configured is the default one which comes with Outcome.\nThe way we are going to configure interop is as follows:\n The application shall use error_code for anticipated failure and C++ exception throws for unanticipated failure. We shall choose the convention that app::outcome with exception ptr solely and exclusively represents a type erased failure from a third party library.  Thus if one calls .value() on an app::outcome, both anticipated failure within the app and type erased failure from a third party library shall be converted to a C++ exception throw.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/happens3/",
	"title": "-- Now what happens?",
	"tags": [],
	"description": "",
	"content": "Let us run the code from the previous page:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_error_code_enums2 Exception thrown was failure1 ned@lyta:~/outcome/build_posix$  Ah so now we are throwing a C++ exception on no-value observation! This is because we registered our error code enum with the C++ standard library and in so doing, we also told the standard library how our error code interacts with std::error_code and thus std::system_error.\nOutcome\u0026rsquo;s default action when no-value observing a result or outcome with a EC type where some ADL discovered free function make_error_code(EC) returning a std::error_code exists1, is to throw a std::system_error(make_error_code(.error())). This is how the failure_info custom EC type was annotated to be treated as a std::error_code in the previous section of the tutorial, this is the exact same mechanism2.\nSo above, because .error() is set to err::failure1, the free function we defined make_error_code(err) converts that into a std::error_code, and from that the std::system_error is constructed and thrown during a no-value value observation.\nOn catching a std::exception, we print the what() which this particular standard library implementation (libstdc++) has chosen to set to error_code::message().\n trait::has_error_code\u0026lt;EC\u0026gt; determines this. [return] One only needs to additionally define the throw_as_system_error_with_payload() free function if type EC does not have std::is_error_code_enum\u0026lt;EC\u0026gt; nor std::is_error_condition_enum\u0026lt;EC\u0026gt; defined as true. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/payload/copy_file3/",
	"title": "Auto-throwing filesystem_error",
	"tags": ["default-actions", "value"],
	"description": "",
	"content": "Something not mentioned at all until now (and properly described in the next section, Default actions) is that Outcome can be programmed take various actions when the user tries to observe .value() when there is no value, and so on for the other possible state observations.\nSeeing as we are replacing the throwing overload of copy_file() in the Filesystem TS with a result returning edition instead, it would make sense if an attempt to observe the value of an unsuccessful fs_result threw the exact same filesystem_error as the Filesystem TS does.\nTelling Outcome how to throw a filesystem_error with payload of the failing paths is easy:\nnamespace filesystem2 { // If we would like Outcome to do something other than the default action (see next  // section), we can declare this ADL discovered free function to customise what  // to do instead.  //  // Note that rvalue semantics are propagated internally by Outcome, so if the user  // called .value() on a rvalued result, failure_info will be moved rather than  // copied from the result. That means we can overload once with value semantics,  // and not need to overload for lvalue and rvalue situations unless we really feel  // we need to for some reason.  inline void outcome_throw_as_system_error_with_payload(failure_info fi) { // If the error code is not filesystem related e.g. ENOMEM, throw that as a standard STL exception.  outcome::try_throw_std_exception_from_error(fi.ec); // Throw the exact same filesystem_error exception which the throwing copy_file() edition does.  throw filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec); } } View this code on Github Usage of our new \u0026ldquo;upgraded\u0026rdquo; Filesystem copy_file() might now be as follows:\n// Non-throwing use case  auto o = filesystem2::copy_file(\u0026#34;dontexist\u0026#34;, \u0026#34;alsodontexist\u0026#34;); if(!o) { std::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with error \u0026#34; \u0026lt;\u0026lt; o.error().ec.message() //  \u0026lt;\u0026lt; \u0026#34; (path1 = \u0026#34; \u0026lt;\u0026lt; o.error().path1 \u0026lt;\u0026lt; \u0026#34;, path2 = \u0026#34; \u0026lt;\u0026lt; o.error().path2 \u0026lt;\u0026lt; \u0026#34;)\u0026#34; //  \u0026lt;\u0026lt; std::endl; } // Throwing use case  try { // Try to observe the successful value, thus triggering default actions which invokes  // our outcome_throw_as_system_error_with_payload() above which then throws filesystem_error  // exactly like the Filesystem TS does for its throwing overload.  filesystem2::copy_file(\u0026#34;dontexist\u0026#34;, \u0026#34;alsodontexist\u0026#34;).value(); } catch(const filesystem2::filesystem_error \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with exception \u0026#34; \u0026lt;\u0026lt; e.what() //  \u0026lt;\u0026lt; \u0026#34; (path1 = \u0026#34; \u0026lt;\u0026lt; e.path1() \u0026lt;\u0026lt; \u0026#34;, path2 = \u0026#34; \u0026lt;\u0026lt; e.path2() \u0026lt;\u0026lt; \u0026#34;)\u0026#34; //  \u0026lt;\u0026lt; std::endl; } catch(const std::exception \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Copy file failed with exception \u0026#34; \u0026lt;\u0026lt; e.what() //  \u0026lt;\u0026lt; std::endl; } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/policies/builtin/",
	"title": "Built-in policies",
	"tags": [],
	"description": "",
	"content": "These are the precanned policies built into Outcome:\n  all_narrow  Wide checks call their narrow check cousins only. If there is an observation of a value/error/exception which is not present, the narrow checks call a function called _ub() which:\n Is marked with any compiler-specific markup to say it will never return, which should cause the compiler\u0026rsquo;s optimiser to generate perfectly minimum code. Calls __builtin_unreachable() on compilers which support that intrinsic to further encourage perfectly minimum code (and to trigger the undefined behaviour sanitiser if execution ever reaches such a code path).   error_code_throw_as_system_error\u0026lt;T, EC, EP\u0026gt;  Policy interpreting either EC as meeting the std::error_code contract, and EP as optionally meeting the std::exception_ptr contract. If there is no value and EP is set to an exception ptr, .value() will std::rethrow_exception(exception) or std::rethrow_exception(make_exception_ptr(exception)). If there is no value and EP is not set to an exception ptr, .value() will OUTCOME_THROW_EXCEPTION(std::system_error(error)) or OUTCOME_THROW_EXCEPTION(std::system_error(make_error_code(error))) if EC is implicitly convertible to a std::error_code, or is an error code enum or error condition enum, otherwise it will invoke the ADL discovered free function throw_as_system_error_with_payload(error). .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(\u0026quot;no error\u0026quot;)) or OUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026quot;no error\u0026quot;)) if there is no error. .exception() willOUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026quot;no exception\u0026quot;)) if there is no exception. The narrow checks are the same as for the all_narrow policy.\n  exception_ptr_rethrow\u0026lt;T, EC, EP\u0026gt;  Policy interpreting either or both EC and EP as meeting the std::exception_ptr contract. If there is no value, .value() will std::rethrow_exception(error) or std::rethrow_exception(make_exception_ptr(error)) if EP is void, else std::rethrow_exception(exception) or std::rethrow_exception(make_exception_ptr(exception)) or std::rethrow_exception(error) or std::rethrow_exception(make_exception_ptr(error)) as appropriate. .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(\u0026quot;no error\u0026quot;)) or OUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026quot;no error\u0026quot;)) if there is no error. .exception() willOUTCOME_THROW_EXCEPTION(bad_outcome_access(\u0026quot;no exception\u0026quot;)) if there is no exception. The narrow checks are the same as for the all_narrow policy.\n  terminate  Wide checks call std::terminate if they fail. The narrow checks are the same as for the all_narrow policy.\n  throw_bad_result_access\u0026lt;EC\u0026gt;  Policy implementing throws of bad_result_access_with\u0026lt;EC\u0026gt;. .value() will OUTCOME_THROW_EXCEPTION(bad_result_access_with\u0026lt;EC\u0026gt;(error)) if there is no value, .error() will OUTCOME_THROW_EXCEPTION(bad_result_access(\u0026quot;no error\u0026quot;)) if there is no error. The narrow checks are the same as for the all_narrow policy. This policy can be used with outcome, but any EP state is ignored and will appear to the policy as if neither value nor error is set, so .value() in this situation would OUTCOME_THROW_EXCEPTION(bad_result_access(\u0026quot;no value\u0026quot;)).\n  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/example2/",
	"title": "Calling it from C",
	"tags": [],
	"description": "",
	"content": "Now let us call our result returning C++ function from C:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; // for strerror// This header in Outcome is pure C, it provides a suite of C helper macros #include \u0026#34;../../../include/outcome/result.h\u0026#34; // Declare our C++ function\u0026#39;s returning result type. Only needs to be done once. CXX_DECLARE_RESULT_EC(size_t, size_t); // Tell C about our C++ function extern CXX_RESULT_EC(size_t) to_string(char *buffer, size_t bufferlen, int v); void print(int v) { char buffer[4]; CXX_RESULT_EC(size_t) res; res = to_string(buffer, sizeof(buffer), v); if(CXX_RESULT_HAS_VALUE(res)) { printf(\u0026#34;to_string(%d) fills buffer with \u0026#39;%s\u0026#39; of %zu characters\\n\u0026#34;, v, buffer, res.value); return; } // Is the error returned in the std::generic_category domain and thus an errno?  if(CXX_RESULT_ERROR_IS_ERRNO(res)) { // If you get a weird compile error here, note that CXX_RESULT_ERROR()  // uses C11 generics, you need a C11 compiler for it to work. If you don\u0026#39;t  // have a C11 compiler, res.error or res.error.code can be used directly.  fprintf(stderr, \u0026#34;to_string(%d) failed with error code %d (%s)\\n\u0026#34;, v, CXX_RESULT_ERROR(res), strerror(CXX_RESULT_ERROR(res))); return; } fprintf(stderr, \u0026#34;to_string(%d) failed with unknown error code %d\\n\u0026#34;, v, CXX_RESULT_ERROR(res)); } int main(void) { print(9); print(99); print(999); print(9999); return 0; } View this code on Github Running this C program yields:\nto_string(9) fills buffer with '9' of 1 characters to_string(99) fills buffer with '99' of 2 characters to_string(999) fills buffer with '999' of 3 characters to_string(9999) failed with error code 105 (No buffer space available)  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/payload/",
	"title": "Custom payloads",
	"tags": ["payload", "has_error_code", "make_error_code"],
	"description": "Success-or-failure return types where extra information in addition to the error code accompanies failure.",
	"content": "So far in this tutorial, type EC in result\u0026lt;T, EC\u0026gt; has always been a std::error_code (though it can be of any type you wish instead). EC needs in fact to merely satisfy  trait::has_error_code_v\u0026lt;EC\u0026gt; for EC to be treated as if an std::error_code.\nIn turn, trait::has_error_code_v\u0026lt;EC\u0026gt; is true if there exists some ADL discovered free function:\n make_error_code(EC) returning a std::error_code. make_error_code(get\u0026lt;0\u0026gt;(EC)) returning a std::error_code (i.e. EC might be pair\u0026lt;std::error_code, U\u0026gt; or tuple\u0026lt;std::error_code, ...\u0026gt;).  \u0026hellip; or if EC is implicitly convertible into a std::error_code.\nThus, we can in fact use any custom EC type we like, including one carrying additional information, or payload. This payload can carry anything you like, and you can tell Outcome to do various things with that payload under various circumstances. For example:\n If the user tries to observe an unsuccessful result, throw a custom exception containing the cause of failure with accompanying context from the payload. If the user ever constructs an outcome from a payload carrying result, set the exception ptr in the constructed outcome to a custom exception containing the cause of the failure with accompanying context from the payload. Transmit a stack backtrace specifying the exact point at which failure occurred, symbolising that backtrace into human readable text at the moment of conversion into human readable text. Upon a namespace-localised result from library A being copy/moved into a namespace-localised result from C bindings library B, set the C errno if the error code and category map onto the errno domain.  There are many, many other options of course. This tutorial can only cover a reasonable subset. This section covers Example 1 above, throwing custom exceptions with payload upon observation of an unsuccessful result.\n"
},
{
	"uri": "https://ned14.github.io/outcome/faq/",
	"title": "Frequently asked questions",
	"tags": [],
	"description": "",
	"content": "    Can I use Outcome to write zero overhead deterministic exceptions as is proposed to enter C++ 23? Is Outcome safe to use in extern APIs? Does Outcome have a stable ABI and API? Why two types result\u0026lt;\u0026gt; and outcome\u0026lt;\u0026gt; rather than just one? How badly will including Outcome in my public interface affect compile times? Is Outcome suitable for fixed latency/predictable execution coding such as for high frequency trading or audio? What kind of performance benefits will using Outcome in my code bring? Why is implicit default construction disabled? How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Why doesn\u0026rsquo;t Outcome duplicate std::expected\u0026lt;T, E\u0026gt;\u0026rsquo;s design?    Can I use Outcome to write zero overhead deterministic exceptions as is proposed to enter C++ 23? Technically yes:\n// Switch this to 0 if you have deterministic exceptions support in your compiler #define OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION 1  #include \u0026#34;outcome/try.hpp\u0026#34;#include \u0026#34;outcome/experimental/status_result.hpp\u0026#34; /*! Declare an API which throws a deterministic exception. Will compile into deterministic exceptions, or an emulation. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_THROWS_API(rettype, errtype, ...) ::OUTCOME_V2_NAMESPACE::experimental::erased_result\u0026lt;rettype, errtype\u0026gt; __VA_ARGS__ noexcept #else #define OUTCOME_THROWS_API(rettype, errtype, ...) rettype __VA_ARGS__ throws(errtype) #endif  /*! Declare an API which deterministically throws the default std::error. Will compile into deterministic exceptions, or an emulation. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_THROWS_ERROR_API(rettype, ...) ::OUTCOME_V2_NAMESPACE::experimental::erased_result\u0026lt;rettype, ::SYSTEM_ERROR2_NAMESPACE::error\u0026gt; __VA_ARGS__ noexcept #else #define OUTCOME_THROWS_ERROR_API(rettype, ...) rettype __VA_ARGS__ throws(std::error) #endif  /*! Throws a deterministic exception. Will compile into deterministic exceptions, or an emulation. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_THROW(...) return ::OUTCOME_V2_NAMESPACE::failure(__VA_ARGS__) #else #define OUTCOME_THROW(...) throw(__VA_ARGS__) #endif  /*! Call an API. Will compile into deterministic exceptions, or an emulation. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_CALL_API(...) OUTCOME_TRY(...) #else #define OUTCOME_CALL_API(...) (__VA_ARGS__) #endif  /*! Catch any deterministic exceptions thrown by an expression into a ValueOrError concept matching type. */ #if OUTCOME_DETERMINISTIC_EXCEPTIONS_USE_EMULATION #define OUTCOME_CATCH_EXPR(...) (...) #else #define OUTCOME_CATCH_EXPR(...) catch(__VA_ARGS__) #endif You would then have to write your code in this quite unnatural form:\n// Throws ::SYSTEM_ERROR2_NAMESPACE::error, the proposed std::error for P0709 Zero // overhead deterministic exceptions OUTCOME_THROWS_ERROR_API(int, foo(double x)) { if(x \u0026lt; INT_MIN || x \u0026gt; INT_MAX) OUTCOME_THROW(::SYSTEM_ERROR2_NAMESPACE::errc::result_out_of_range); return static_cast\u0026lt;int\u0026gt;(x); } ... int v = OUTCOME_CALL_API(foo(5.0)); As much as it is technically feasible, it is probably not worth inudating your C++ code with so many macros, especially as Outcome will continue to work just fine in future C++ compilers.\nIs Outcome safe to use in extern APIs? Outcome is specifically designed for use in the public interfaces of multi-million line codebases. Its layout is hard coded to:\nstruct { T value; unsigned int flags; EC error; }; This is, of course, C-compatible and Outcome provides a macro-based C interface for C code needing to call extern \u0026quot;C\u0026quot; C++ functions returning a result\u0026lt;T, EC\u0026gt;.\nDoes Outcome have a stable ABI and API? Until Outcome passes a second Boost peer review and enters Boost, no. Once into Boost, Outcome\u0026rsquo;s ABI and API will be formally fixed as the v2 interface one year after its first Boost release. Thereafter the ABI compliance checker will be run per-commit to ensure Outcome\u0026rsquo;s ABI and API remains stable.\nNote that the stable ABI and API guarantee will only apply to standalone Outcome, not to Boost.Outcome. Boost.Outcome has dependencies on other parts of Boost which are not stable across releases.\nWhy two types result\u0026lt;\u0026gt; and outcome\u0026lt;\u0026gt; rather than just one? The two types represent slightly different things. Using two types allows expressing programmer\u0026rsquo;s intentions more directly.\nFunction signature result\u0026lt;T\u0026gt; f() noexcept means that any failures in f are exclusively reported by returning an error code.\nSimilarly, signature result\u0026lt;T\u0026gt; f() means that in addition to the above, some failures in f are signalled by throwing exceptions.\nNow, signature outcome\u0026lt;T\u0026gt; g() noexcept means that in the lower layers of the implementation we have two kinds of libraries/modules: some report failures via error codes, and some by throwing exceptions. But at the level of our interface we do not want to throw exceptions; so we forward both error codes and exceptions unaltered. The callers can easily tell which type of failure reporting was chosen, and extract it appropriately.\nAdditionally, outcome\u0026lt;T\u0026gt; can store both EC and EP at the same time. The caller of the function can choose whether to inspect the exception that provides more information and context, or to go with the error code which can be processed faster and in a more uniform way.\nThis implies that outcome\u0026lt;\u0026gt; has different interface that allows you to ask whether we are storing an exception or an error code to rethrow the stored exception but to return by value the error code, etc.\nThere is one additional possibility. When you know there will be no error codes returned \u0026ndash; only exceptions thrown, but at some layer you want to temporarily change the stack unwinding into returning failures through return values, you can use signature:\nresult\u0026lt;T, std::exception_ptr\u0026gt; f() noexcept; How badly will including Outcome in my public interface affect compile times? Outcome is dependent on \u0026lt;system_error\u0026gt;, which unfortunately includes \u0026lt;string\u0026gt; and thus drags in quite a lot of other stuff. If your public interface already includes \u0026lt;string\u0026gt;, then the impact of including Outcome will be very low. If you do not include \u0026lt;string\u0026gt;, unfortunately impact may be relatively quite high, depending on the total impact of your public interface files.\nMeasures are being taken to remedy this situation however. The first is that C++ Modules will eliminate much of the impact of being dependent on \u0026lt;string\u0026gt;, and Outcome will make use of C++ Modules where enabled as soon as a compiler does not ICE on Outcome (i.e. Modules support is implemented specifically for the Microsoft compiler, but said compiler still internal compiler errors when attempting to create an Outcome Module. Microsoft are aware of the cause and hope to fix it within the next year or two).\nLonger term, SG14 the WG21 study group for low latency/high performance C++ are working on a \u0026lt;system_error2\u0026gt; which remedies some of the problems in \u0026lt;system_error\u0026gt;. The dependency on \u0026lt;string\u0026gt; has been removed, and thus any \u0026lt;system_error2\u0026gt; would be considerably lower impact. An Outcome v3 is likely to support any proposed \u0026lt;system_error2\u0026gt;, and that is likely many years away yet as ISO standardisation takes time.\nIs Outcome suitable for fixed latency/predictable execution coding such as for high frequency trading or audio? Great care has been taken to ensure that Outcome never unexpectedly executes anything with unbounded execution times such as malloc(), dynamic_cast\u0026lt;\u0026gt;() or throw. Outcome works perfectly with C++ exceptions and RTTI globally disabled.\nOutcome\u0026rsquo;s entire design premise is that its users are happy to exchange a small, predictable constant overhead during successful code paths, in exchange for completely predictable failure code paths. In contrast, table-based exception handling gives zero run time overhead for the successful code path, and completely unpredictable (and very expensive) overhead for failure code paths.\nFor code where predictability of execution no matter the code path is paramount, writing all your code to use Outcome is not a bad place to start. Obviously enough, do choose a non-throwing policy when configuring outcome or result such as policy::all_narrow to guarantee that exceptions can never be thrown by Outcome (or use the convenience typedef for result, unchecked which uses policy::all_narrow).\nWhat kind of performance benefits will using Outcome in my code bring? It is very hard to say anything definitive about performance impacts in codebases one has never seen. Each codebase is unique. However to come up with some form of measure, we timed returning an error via each of the main mechanisms, doing so over ten stack frames. A stack frame is defined to be something called by the compiler whilst unwinding the stack between the point of returning the error and the thing which handles the error, so for example ten stack allocated objects might be destructed, or ten levels of stack depth might be unwound. This is not a particularly realistic test, but it should at least give one an idea of the performance impact of returning Outcome\u0026rsquo;s result or outcome over say returning a plain integer, or throwing an exception.\n Log graph comparing GCC 7.2, clang 5.0, Visual Studio 2017.5 and XCode 8.2   As you can see, throwing and catching an exception is expensive on table-based exception handling implementations such as these, anywhere between 16,000 and 36,000 CPU cycles. Simple integer returns are always going to be the fastest as they do the least work, and that costs 90 to 100 CPU cycles.\nNote that returning a result\u0026lt;int, std::error_code\u0026gt; with an int (result-error-value) is no additional runtime overhead over returning a naked int on most compilers.\nReturning a result\u0026lt;int, std::error_code\u0026gt; with an error code (result-error-error) is no additional runtime overhead over returning a naked int on most compilers.\nYou might wonder what happens if type E has a non-trivial destructor, thus making the result\u0026lt;T, E\u0026gt; have a non-trivial destructor? We tested E = std::exception_ptr and found no performance difference to E = std::error_code for returning a value. Returning an error was obviously much slower at anywhere between 300 and 1,500 CPU cycles due to returning an exception pointer being at least two atomic operations per stack frame, but that is still two orders of magnitude better than throwing and catching an exception.\nWe conclude that if failure is anything but extremely rare in your C++ codebase, using Outcome instead of throwing and catching exceptions ought to be quicker overall.\nWhy is implicit default construction disabled? This was one of the more interesting points of discussion during the peer review of Outcome v1. v1 had a formal empty state. This came with many advantages, but it was not felt to be STL idiomatic as std::optional\u0026lt;result\u0026lt;T\u0026gt;\u0026gt; is what was meant, so v2 has eliminated any legal possibility of being empty.\nThe expected\u0026lt;T, E\u0026gt; proposal of that time (May 2017) did permit default construction if its T type allowed default construction. This was specifically done to make expected\u0026lt;T, E\u0026gt; more useful in STL containers as one can say resize a vector without having to supply an expected\u0026lt;T, E\u0026gt; instance to fill the new items with. However there was some unease with that design choice, because it may cause programmers to use some type T whose default constructed state is overloaded with additional meaning, typically \u0026ldquo;to be filled\u0026rdquo; i.e. a de facto empty state via choosing a magic value.\nFor the v2 redesign, the various arguments during the v1 review were considered. Unlike expected\u0026lt;T, E\u0026gt; which is intended to be a general purpose Either monad vocabulary type, Outcome\u0026rsquo;s types are meant primarily for returning success or failure from functions. The API should therefore encourage the programmer to not overload the successful type with additional meaning of \u0026ldquo;to be filled\u0026rdquo; e.g. result\u0026lt;std::optional\u0026lt;T\u0026gt;\u0026gt;. The decision was therefore taken to disable implicit default construction, but still permit explicit default construction by making the programmer spell out their intention with extra typing.\nTo therefore explicitly default construct a result\u0026lt;T\u0026gt; or outcome\u0026lt;T\u0026gt;, use one of these forms as is the most appropriate for the use case:\n Construct with just in_place_type\u0026lt;T\u0026gt; e.g. result\u0026lt;T\u0026gt;(in_place_type\u0026lt;T\u0026gt;). Construct via success() e.g. outcome\u0026lt;T\u0026gt;(success()). Construct from a void form e.g. result\u0026lt;T\u0026gt;(result\u0026lt;void\u0026gt;(in_place_type\u0026lt;void\u0026gt;)).  How far away from the proposed std::expected\u0026lt;T, E\u0026gt; is Outcome\u0026rsquo;s checked\u0026lt;T, E\u0026gt;? Not far, in fact after the Boost.Outcome peer review in May 2017, Expected moved much closer to Outcome. Here are the remaining differences which represent the divergence of consensus opinion between the Boost peer review and WG21 on the proper design for this object:\n checked\u0026lt;T, E\u0026gt; has no default constructor. Expected has a default constructor if T has a default constructor. checked\u0026lt;T, E\u0026gt; uses the same constructor design as std::variant\u0026lt;...\u0026gt;. Expected uses the constructor design of std::optional\u0026lt;T\u0026gt;. checked\u0026lt;T, E\u0026gt; cannot be modified after construction except by assignment. Expected provides an .emplace() modifier. checked\u0026lt;T, E\u0026gt; permits implicit construction from both T and E when unambiguous. Expected permits implicit construction from T alone. checked\u0026lt;T, E\u0026gt; does not permit T and E to be the same, and becomes annoying to use if they are constructible into one another (implicit construction self-disables). Expected permits T and E to be the same. checked\u0026lt;T, E\u0026gt; throws bad_result_access_with\u0026lt;E\u0026gt; instead of Expected\u0026rsquo;s bad_expected_access\u0026lt;E\u0026gt;. checked\u0026lt;T, E\u0026gt; models std::variant\u0026lt;...\u0026gt;. Expected models std::optional\u0026lt;T\u0026gt;. Thus:  checked\u0026lt;T, E\u0026gt; does not provide operator*() nor operator-\u0026gt; checked\u0026lt;T, E\u0026gt; .error() is wide (i.e. throws on no-value) like .value(). Expected\u0026rsquo;s .error() is narrow (UB on no-error). (checked\u0026lt;T, E\u0026gt; provides .assume_value() and .assume_error() for narrow (UB causing) observers)  checked\u0026lt;T, E\u0026gt; uses success\u0026lt;T\u0026gt; and failure\u0026lt;E\u0026gt; type sugars for disambiguation. Expected uses unexpected\u0026lt;E\u0026gt; only. checked\u0026lt;T, E\u0026gt; requires E to be default constructible. checked\u0026lt;T, E\u0026gt; defaults E to std::error_code. Expected does not default E.  In fact, the two are sufficiently close in design that a highly conforming expected\u0026lt;T, E\u0026gt; can be implemented by wrapping up checked\u0026lt;T, E\u0026gt; with the differing functionality:\n/* Here is a fairly conforming implementation of P0323R3 `expected\u0026lt;T, E\u0026gt;` using `checked\u0026lt;T, E\u0026gt;`. It passes the reference test suite for P0323R3 at https://github.com/viboes/std-make/blob/master/test/expected/expected_pass.cpp with modifications only to move the test much closer to the P0323R3 Expected, as the reference test suite is for a much older proposed Expected. Known differences from P0323R3 in this implementation: - `T` and `E` cannot be the same type. - `E` must be default constructible. - No variant storage is implemented (note the Expected proposal does not actually require this). */ namespace detail { template \u0026lt;class T, class E\u0026gt; using expected_result = OUTCOME_V2_NAMESPACE::checked\u0026lt;T, E\u0026gt;; template \u0026lt;class T, class E\u0026gt; struct enable_default_constructor : public expected_result\u0026lt;T, E\u0026gt; { using base = expected_result\u0026lt;T, E\u0026gt;; using base::base; constexpr enable_default_constructor() : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;} { } }; template \u0026lt;class T, class E\u0026gt; using select_expected_base = std::conditional_t\u0026lt;std::is_default_constructible\u0026lt;T\u0026gt;::value, enable_default_constructor\u0026lt;T, E\u0026gt;, expected_result\u0026lt;T, E\u0026gt;\u0026gt;; } template \u0026lt;class T, class E\u0026gt; class expected : public detail::select_expected_base\u0026lt;T, E\u0026gt; { static_assert(!std::is_same\u0026lt;T, E\u0026gt;::value, \u0026#34;T and E cannot be the same in this expected implementation\u0026#34;); using base = detail::select_expected_base\u0026lt;T, E\u0026gt;; public: // Inherit base\u0026#39;s constructors  using base::base; expected() = default; // Expected takes in_place not in_place_type  template \u0026lt;class... Args\u0026gt; constexpr explicit expected(std::in_place_t /*unused*/, Args \u0026amp;\u0026amp;... args) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...} { } // Expected always accepts a T even if ambiguous  OUTCOME_TEMPLATE(class U) OUTCOME_TREQUIRES(OUTCOME_TPRED(std::is_constructible\u0026lt;T, U\u0026gt;::value)) constexpr expected(U \u0026amp;\u0026amp;v) : base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;U\u0026gt;(v)} { } // Expected has an emplace() modifier  template \u0026lt;class... Args\u0026gt; void emplace(Args \u0026amp;\u0026amp;... args) { *static_cast\u0026lt;base *\u0026gt;(this) = base{OUTCOME_V2_NAMESPACE::in_place_type\u0026lt;T\u0026gt;, std::forward\u0026lt;Args\u0026gt;(args)...}; } // Expected has a narrow operator* and operator-\u0026gt;  constexpr const T \u0026amp;operator*() const \u0026amp; { return base::assume_value(); } constexpr T \u0026amp;operator*() \u0026amp; { return base::assume_value(); } constexpr const T \u0026amp;\u0026amp;operator*() const \u0026amp;\u0026amp; { return base::assume_value(); } constexpr T \u0026amp;\u0026amp;operator*() \u0026amp;\u0026amp; { return base::assume_value(); } constexpr const T *operator-\u0026gt;() const { return \u0026amp;base::assume_value(); } constexpr T *operator-\u0026gt;() { return \u0026amp;base::assume_value(); } // Expected has a narrow error() observer  constexpr const E \u0026amp;error() const \u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp; { return base::assume_error(); } constexpr const E \u0026amp;\u0026amp;error() const \u0026amp;\u0026amp; { return base::assume_error(); } constexpr E \u0026amp;error() \u0026amp;\u0026amp; { return base::assume_error(); } }; template \u0026lt;class E\u0026gt; class expected\u0026lt;void, E\u0026gt; : public OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt; { using base = OUTCOME_V2_NAMESPACE::result\u0026lt;void, E, OUTCOME_V2_NAMESPACE::policy::throw_bad_result_access\u0026lt;E\u0026gt;\u0026gt;; public: // Inherit base constructors  using base::base; // Expected has a narrow operator* and operator-\u0026gt;  constexpr void operator*() const { base::assume_value(); } constexpr void operator-\u0026gt;() const { base::assume_value(); } }; template \u0026lt;class E\u0026gt; using unexpected = OUTCOME_V2_NAMESPACE::failure_type\u0026lt;E\u0026gt;; template \u0026lt;class E\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(E \u0026amp;\u0026amp;arg) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;E\u0026gt;(arg)); } template \u0026lt;class E, class... Args\u0026gt; unexpected\u0026lt;E\u0026gt; make_unexpected(Args \u0026amp;\u0026amp;... args) { return OUTCOME_V2_NAMESPACE::failure\u0026lt;E\u0026gt;(std::forward\u0026lt;Args\u0026gt;(args)...); } template \u0026lt;class E\u0026gt; using bad_expected_access = OUTCOME_V2_NAMESPACE::bad_result_access_with\u0026lt;E\u0026gt;; View this code on Github Why doesn\u0026rsquo;t Outcome duplicate std::expected\u0026lt;T, E\u0026gt;\u0026rsquo;s design? There are a number of reasons:\n Outcome is not aimed at the same audience as Expected. We target developers and users who would be happy to use Boost. Expected targets the standard library user.\n Outcome believes that the monadic use case isn\u0026rsquo;t as important as Expected does. Specifically, we think that 99% of use of Expected in the real world will be to return failure from functions, and not as some sort of enhanced or \u0026ldquo;rich\u0026rdquo; Optional. Outcome therefore models a subset of Variant, whereas Expected models an extended Optional.\n Outcome believes that if you are thinking about using something like Outcome, then for you writing failure code will be in the same proportion as writing success code, and thus in Outcome writing for failure is exactly the same as writing for success. Expected assumes that success will be more common than failure, and makes you type more when writing for failure.\n Outcome goes to considerable effort to help the end user type fewer characters during use. This results in tighter, less verbose, more succinct code. The cost of this is a steeper learning curve and more complex mental model than when programming with Expected.\n Outcome has facilities to make easier interoperation between multiple third party libraries each using incommensurate Outcome configurations. Expected does not do any of this, but subsequent WG21 papers do propose various interoperation mechanisms, one of which Outcome implements so code using Expected will seamlessly interoperate with code using Outcome.\n  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/hook_result/",
	"title": "Hook result",
	"tags": [],
	"description": "",
	"content": "We now tell Outcome that for every instance of our localised result\u0026lt;T\u0026gt;, that on failure construction only, we want custom code to be run which increments the current slot in TLS storage and writes the current stack backtrace into it.\nnamespace error_code_extended { // Specialise the result construction hook for our localised result  // We hook any non-copy, non-move, non-inplace construction, capturing a stack backtrace  // if the result is errored.  template \u0026lt;class T, class U\u0026gt; inline void hook_result_construction(result\u0026lt;T\u0026gt; *res, U \u0026amp;\u0026amp; /*unused*/) noexcept { if(res-\u0026gt;has_error()) { // Grab the next extended info slot in the TLS  extended_error_info \u0026amp;eei = mythreadlocaldata().next(); // Write the index just grabbed into the spare uint16_t  OUTCOME_V2_NAMESPACE::hooks::set_spare_storage(res, mythreadlocaldata().current - 1); // Capture a backtrace into my claimed extended info slot in the TLS  eei.items = ::backtrace(eei.backtrace.data(), eei.backtrace.size()); } } } View this code on Github The only non-obvious part above is the call to  hooks::set_spare_storage() . Both result and outcome keep their internal state metadata in a uint32_t, half of which is not used by Outcome. As it can be very useful to keep a small unique number attached to any particular result or outcome instance, we permit user code to set those sixteen bits to anything they feel like. The corresponding function to retrieve those sixteen bits is  hooks::spare_storage() .\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/outcome/inspecting/",
	"title": "Inspecting outcome&lt;T, EC, EP&gt;",
	"tags": ["outcome", "value", "error", "exception"],
	"description": "",
	"content": "Continuing with the previous example, in Layer3 we have function z which again reports failures via exceptions. It will call function h from Layer2_old which returns outcome\u0026lt;int\u0026gt; (which may store a double or an std::error_code or an std::exception_ptr). The goal is to unpack it to either the successful return value int or to throw an appropriate exception: if we are storing an std::exception_ptr just rethrow it. If we are storing an std::error_code throw it as std::system_error, which is designed to store std::error_code\u0026rsquo;s:\nauto z() -\u0026gt; int // throws on failure { if (outcome::outcome\u0026lt;int\u0026gt; o = old::h()) return o.value(); else if (o.has_exception()) std::rethrow_exception(o.exception()); else throw std::system_error{o.error()}; } View this code on Github Function has_exception checks if it is EP (std::exception_ptr) that is stored, function exception accesses it. Similarly, function error accesses the EC (std::error_code) if it is stored. outcome\u0026lt;\u0026gt; also has a function has_failure to check if either EC or EP is being stored. In fact, the above pattern of \u0026ldquo;unpacking\u0026rdquo; outcome\u0026lt;\u0026gt; is so common that it has been implemented inside function .value(), so function z could be written as:\nreturn old::h().value();"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-map-httplib1/",
	"title": "Mapping the HTTP library into the Application 1/2",
	"tags": [],
	"description": "",
	"content": "Firstly we are going to need to wrap up httplib::failure into a custom STL exception type before we can type erase it into an exception_ptr instance. Please note that this code is defined in the app namespace:\nnamespace app { // Specialise an exception type for httplib errors  struct httplib_error : std::runtime_error { // passthrough  using std::runtime_error::runtime_error; httplib_error(httplib::failure _failure, std::string msg) : std::runtime_error(std::move(msg)) , failure(std::move(_failure)) { } // the original failure  httplib::failure failure; }; // Type erase httplib::result\u0026lt;U\u0026gt; into a httplib_error exception ptr  template \u0026lt;class U\u0026gt; inline std::exception_ptr make_httplib_exception(const httplib::result\u0026lt;U\u0026gt; \u0026amp;src) { std::string str(\u0026#34;httplib failed with error \u0026#34;); switch(src.error().status) { case httplib::status_code::success: str.append(\u0026#34;success\u0026#34;); break; case httplib::status_code::bad_request: str.append(\u0026#34;bad request\u0026#34;); break; case httplib::status_code::access_denied: str.append(\u0026#34;access denied\u0026#34;); break; case httplib::status_code::logon_failed: str.append(\u0026#34;logon failed\u0026#34;); break; case httplib::status_code::forbidden: str.append(\u0026#34;forbidden\u0026#34;); break; case httplib::status_code::not_found: str.append(\u0026#34;not found\u0026#34;); break; case httplib::status_code::internal_error: str.append(\u0026#34;internal error\u0026#34;); break; } str.append(\u0026#34; [url was \u0026#34;); str.append(src.error().url); str.append(\u0026#34;]\u0026#34;); return std::make_exception_ptr(httplib_error(src.error(), std::move(str))); } } View this code on Github The only real thing to note about app::httplib_error is that it squirrels away the original httplib::failure in case that is ever needed. We do, of course, need to create some sort of descriptive string for std::runtime_error so its .what() returns a useful summary of the original failure. This is the purpose of the app::make_httplib_exception() function.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/static-constructor/",
	"title": "Phase 2 construction",
	"tags": [],
	"description": "",
	"content": "Its phase 2 constructor:\n// Phase 2 static member constructor function, which cannot throw inline outcome::result\u0026lt;file_handle\u0026gt; file_handle::file(file_handle::path_type path, file_handle::mode mode) noexcept { // Perform phase 1 of object construction  file_handle ret; // Perform phase 2 of object construction  int flags = 0; switch(mode) { case mode::attr_read: case mode::read: flags = O_RDONLY; break; case mode::attr_write: case mode::write: flags = O_RDWR; break; case mode::append: flags = O_APPEND; break; default: return std::errc::invalid_argument; } ret._fd = ::open(path.u8string().c_str(), flags); if(-1 == ret._fd) { // Note that if we bail out here, ~file_handle() will correctly not call ::close()  return {errno, std::system_category()}; } if(-1 == ::fstat(ret._fd, \u0026amp;ret._stat)) { // Note that if we bail out here, ~file_handle() will correctly call ::close()  return {errno, std::system_category()}; } // Returning ret directly is an area full of compiler specific behaviour quirks,  // so be explicit by wrapping into an initialiser list with embedded move.  return {std::move(ret)}; } View this code on Github The static member function implementing phase 2 firstly calls phase 1 which puts the object into a legally destructible state. We then proceed to implement phase 2 of construction, filling in the various parts as we go, reporting via result any failures.\nRemember that operator new has a non-throwing form, new(std::nothrow).\n For the final return, in theory we could just return ret and depending on the C++ version currently in force, it might work via move, or via copy, or it might refuse to compile. You can of course type lots of boilerplate to be explicit, but this use via initialiser list is a reasonable balance of explicitness versus brevity, and it should generate minimum overhead code irrespective of compiler, C++ version, or any other factor.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/result/try/",
	"title": "TRY operations",
	"tags": ["try"],
	"description": "",
	"content": "In the implementation of function print_half we have seen the usage of the macro  OUTCOME_TRY :\nOUTCOME_TRY (i, (BigInt::fromString(text))); The OUTCOME_TRY macro uses C macro overloading to select between two implementations based on the number of input parameters. If there is exactly one input parameter i.e. without the i,, the control statement is roughly equivalent to:\nauto\u0026amp;\u0026amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure(); Where __result is a compile time generated unique name. If there are between two and eight parameters, this control statement is roughly equivalent to:\nauto\u0026amp;\u0026amp; __result = BigInt::fromString(text); if (!__result) return __result.as_failure(); auto\u0026amp;\u0026amp; i = __result.value(); So here i as the first C macro parameter is set to the value of any successful result. To prevent confounding of the C preprocessor, you should always wrap the function invocation in brackets. This is done throughout this tutorial.\nAdditionally, in GCC and Clang which provide an extension to C++ known as statement expressions it is possible to use an alternative macro: OUTCOME_TRYX, which is an expression. With the above macro, the above declaration of variable i can be rewritten to:\nint i = OUTCOME_TRYX (BigInt::fromString(text)); This has an advantage that you can use it any place where you can put an expression, e.g., in \u0026ldquo;simple initialization\u0026rdquo;:\nif (int i = OUTCOME_TRYX(BigInt::fromString(text))) use_a_non_zero_int(i); or in as a subexpression of a bigger full expression:\nint ans = OUTCOME_TRYX(BigInt::fromString(\u0026#34;1\u0026#34;)) + OUTCOME_TRYX(BigInt::fromString(\u0026#34;2\u0026#34;)); This macro makes use of a proprietary extension in GCC and clang and is not portable. The macro is not made available on unsupported compilers, so you can test for its presence using #ifdef OUTCOME_TRYX.\n Macro OUTCOME_TRY does two things:\n It extracts a T from result\u0026lt;T\u0026gt; (or outcome\u0026lt;T\u0026gt;). It declares a dependency between statements: If the \u0026ldquo;tried\u0026rdquo; statement fails, the next statement is not executed.  When you are calling functions that return result\u0026lt;void\u0026gt; the first of the two things does not make sense. You then have to use macro OUTCOME_TRYV instead. Let\u0026rsquo;s use our function print_half:\noutcome::result\u0026lt;void\u0026gt; test() { OUTCOME_TRY ((print_half(\u0026#34;2\u0026#34;))); OUTCOME_TRY ((print_half(\u0026#34;X\u0026#34;))); OUTCOME_TRY ((print_half(\u0026#34;4\u0026#34;))); // will not execute  return outcome::success(); } View this code on Github The first statement will succeed. The second statement will \u0026ldquo;fail\u0026rdquo;, i.e. it will return an errored result. This will cause an immediate return and the subsequent statements will be skipped.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/try/",
	"title": "Try operations",
	"tags": [],
	"description": "",
	"content": " Header file try.hpp \nnamespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;auto try_operation_return_as(T\u0026amp;\u0026amp;\u0026nbsp;v); } #define OUTCOME_TRYV(...) #define OUTCOME_TRYX(...) #define OUTCOME_TRY(v,...)  \nFunction outcome_v2_xxx::try_operation_return_as \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; auto\u0026nbsp;try_operation_return_as(T\u0026amp;\u0026amp;\u0026nbsp;v);  Customisation point for changing what the OUTCOME_TRY macros do. This function defaults to returning std::forward\u0026lt;T\u0026gt;(v).as_failure().\nEffects: Extracts any state apart from value into a failure_type.\nRequires: The input value to have a .as_failure() member function.\nMacro OUTCOME_TRYV \n#define\u0026nbsp;OUTCOME_TRYV(...)\u0026nbsp;OUTCOME_TRYV2(OUTCOME_TRY_UNIQUE_NAME, __VA_ARGS__)  If the outcome returned by expression ‚Ä¶ is not valued, propagate any failure by immediately returning that failure state immediately\nMacro OUTCOME_TRYX \n#define\u0026nbsp;OUTCOME_TRYX(...)\u0026nbsp;({ auto \u0026amp;\u0026amp;res = (__VA_ARGS__); if(!res.has_value()) return OUTCOME_V2_NAMESPACE::try_operation_return_as(std::forward\u0026lt;decltype(res)\u0026gt;(res)); std::forward\u0026lt;decltype(res)\u0026gt;(res).value(); })  If the outcome returned by expression ‚Ä¶ is not valued, propagate any failure by immediately returning that failure state immediately, else become the unwrapped value as an expression. This makes OUTCOME_TRYX(expr) an expression which can be used exactly like the try operator in other languages.\nRemarks: This macro makes use of a proprietary extension in GCC and clang and is not portable. The macro is not made available on unsupported compilers, so you can test for its presence using #ifdef OUTCOME_TRYX.\nMacro OUTCOME_TRY \n#define\u0026nbsp;OUTCOME_TRY(v,...)\u0026nbsp;OUTCOME_TRY2(OUTCOME_TRY_UNIQUE_NAME, v, __VA_ARGS__)  If the outcome returned by expression ‚Ä¶ is not valued, propagate any failure by immediately returning that failure immediately, else set v to the unwrapped value.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/error-codes/",
	"title": "error_code",
	"tags": [],
	"description": "",
	"content": "Now that we have told the C++ standard library about our custom error code enum err, we actually no longer need to specify EC = err, we can just leave it default to std::error_code:\nresult\u0026lt;udt /*, std::error_code */\u0026gt; res(err::failure1); // What happens here? What exception type is thrown?  try { std::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl; } catch(const std::exception \u0026amp;e) { // Prints \u0026#34;Exception thrown was failure1\u0026#34;, exactly the same as before  std::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } View this code on Github The reason that this works is because std::error_code provides implicit construction from any type with the trait std::is_error_code_enum\u0026lt;\u0026gt; defined to be true, it uses the ADL discovered free function make_error_code() during that implicit construction.\nThe big advantage of always using EC = std::error_code is that OUTCOME_TRY only works when the EC type is the same (or convertible to) in the try expression as the calling function, so by leaving it at the default of std::error_code, we can use OUTCOME_TRY and save having to type boilerplate:\nresult\u0026lt;udt\u0026gt; boo() { return err::failure1; } result\u0026lt;udt\u0026gt; foo() { OUTCOME_TRY(v, (boo())); return udt{5}; // emplace construct udt with 5 } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/result_error_code_throw_as_system_error/",
	"title": "error_code throw as system_error (Result)",
	"tags": [],
	"description": "",
	"content": " Header file result_error_code_throw_as_system_error.hpp \n#include\u0026nbsp;\u0026quot;detail\u0026#x2F;common.hpp\u0026quot; namespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace\u0026nbsp;policy \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct error_code_throw_as_system_error\u0026lt;T,\u0026nbsp;EC,\u0026nbsp;void\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} }  \n\nStruct outcome_v2_xxx::policy::error_code_throw_as_system_error \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC\u0026gt; struct error_code_throw_as_system_error\u0026lt;T,\u0026nbsp;EC,\u0026nbsp;void\u0026gt; { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; };  Policy interpreting EC as a type for which trait::has_error_code_v\u0026lt;EC\u0026gt; is true.\nAny wide attempt to access the successful state where there is none causes:\n If trait::has_error_payload_v\u0026lt;EC\u0026gt; is true, it calls an ADL discovered free function throw_as_system_error_with_payload(.error()).\n If trait::has_error_payload_v\u0026lt;EC\u0026gt; is false, it calls OUTCOME_THROW_EXCEPTION(std::system_error(policy::error_code(.error())))\n  Function outcome_v2_xxx::policy::throw_bad_result_access::narrow_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::error_code_throw_as_system_error::wide_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the value() functions.\nEffects: See description of class for effects.\nFunction outcome_v2_xxx::policy::error_code_throw_as_system_error::wide_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-map-httplib2/",
	"title": "Mapping the HTTP library into the Application 2/2",
	"tags": [],
	"description": "",
	"content": "If you remember the tutorial section on the ValueOrError Concept, this is an example of how to implement a custom ValueOrError Concept converter in Outcome:\n// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from httplib::result\u0026lt;U\u0026gt; into any app::outcome\u0026lt;T\u0026gt;  template \u0026lt;class T, class U\u0026gt; struct value_or_error\u0026lt;app::outcome\u0026lt;T\u0026gt;, httplib::result\u0026lt;U\u0026gt;\u0026gt; { // False to indicate that this converter wants `result`/`outcome` to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template \u0026lt;class X, //  typename = std::enable_if_t\u0026lt;std::is_same\u0026lt;httplib::result\u0026lt;U\u0026gt;, std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value //  \u0026amp;\u0026amp; std::is_constructible\u0026lt;T, U\u0026gt;::value\u0026gt;\u0026gt; //  constexpr app::outcome\u0026lt;T\u0026gt; operator()(X \u0026amp;\u0026amp;src) { // Forward any successful value, else synthesise an exception ptr  return src.has_value() ? //  app::outcome\u0026lt;T\u0026gt;{std::forward\u0026lt;X\u0026gt;(src).value()} //  : app::outcome\u0026lt;T\u0026gt;{app::make_httplib_exception(std::forward\u0026lt;X\u0026gt;(src))}; } }; } OUTCOME_V2_NAMESPACE_END View this code on Github The first thing that you should note is that these custom converters must be injected directly into the OUTCOME_V2_NAMESPACE::convert namespace, and they must partially or completely specialise struct value_or_error\u0026lt;DEST, SRC\u0026gt;.\nThe second thing to note is that you need to set enable_result_inputs and enable_outcome_inputs appropriately. The reason that these are here is because of a chicken-or-egg problem whereby the ValueOrError infrastructure needs to be defined before result can be defined, and we also wish to permit inclusion of result without needing to include outcome. So this is a slightly irritating workaround, but one with low impact.\nThe third thing to note is the SFINAE on operator(). If the SFINAE fails, the ValueOrError converting constructor disables. Obviously, if you are using Concept requirements, that works too. Note the requirement that SFINAEd X matches httplib::result\u0026lt;U\u0026gt;, and that T is constructible from U.\nIf operator() is available, it naturally converts a httplib::result\u0026lt;U\u0026gt; into an app::outcome\u0026lt;T\u0026gt; by either forwarding any success as-is, or calling app::make_httplib_exception() to type erase the httplib::failure into an app::httplib_error.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/poke_exception/",
	"title": "Custom exception ptr",
	"tags": [],
	"description": "",
	"content": "If you merely want result to capture stack backtraces without calling a memory allocator and retaining any triviality of copy which is important for optimisation, you already have everything you need.\nBut let\u0026rsquo;s keep going by intercepting any construction of our localised outcome from our localised result, retrieving any stored backtrace and using it to synthesise an exception ptr with a message text including the backtrace. Firstly let us look at the function which synthesises the exception ptr:\nnamespace error_code_extended { // Synthesise a custom exception_ptr from the TLS slot and write it into the outcome  template \u0026lt;class R\u0026gt; inline void poke_exception(outcome\u0026lt;R\u0026gt; *o) { if(o-\u0026gt;has_error()) { extended_error_info *eei = mythreadlocaldata().get(OUTCOME_V2_NAMESPACE::hooks::spare_storage(o)); if(eei != nullptr) { // Make a custom string for the exception  std::string str(o-\u0026gt;error().message()); str.append(\u0026#34; [\u0026#34;); char **symbols = ::backtrace_symbols(eei-\u0026gt;backtrace.data(), eei-\u0026gt;items); if(symbols != nullptr) { for(size_t n = 0; n \u0026lt; eei-\u0026gt;items; n++) { if(n \u0026gt; 0) { str.append(\u0026#34;; \u0026#34;); } str.append(symbols[n]); } ::free(symbols); // not exception safe, could leak symbols if appending str fails  } str.append(\u0026#34;]\u0026#34;); // Override the payload/exception member in the outcome with our synthesised exception ptr  OUTCOME_V2_NAMESPACE::hooks::override_outcome_exception(o, std::make_exception_ptr(std::runtime_error(str))); } } } } View this code on Github If the localised outcome being constructed is errored, try fetching the TLS slot for the unique 16-bit value in its spare storage. If that is valid, symbolise the stack backtrace into a string and make an exception ptr with a runtime error with that string. Finally, override the payload/exception member in our just-copy-constructed localised outcome with the new exception ptr.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-map-filelib/",
	"title": "Mapping the File I/O library into the Application",
	"tags": [],
	"description": "",
	"content": "To handle the File I/O library, once again we turn to custom ValueOrError converters:\n// Inject custom ValueOrError conversion OUTCOME_V2_NAMESPACE_BEGIN namespace convert { // Provide custom ValueOrError conversion from filelib::result\u0026lt;U\u0026gt; into any app::outcome\u0026lt;T\u0026gt;  template \u0026lt;class T, class U\u0026gt; struct value_or_error\u0026lt;app::outcome\u0026lt;T\u0026gt;, filelib::result\u0026lt;U\u0026gt;\u0026gt; { // True to indicate that this converter wants `result`/`outcome` to NOT reject all other `result`  static constexpr bool enable_result_inputs = true; // False to indicate that this converter wants `outcome` to NOT reject all other `outcome`  static constexpr bool enable_outcome_inputs = true; template \u0026lt;class X, //  typename = std::enable_if_t\u0026lt;std::is_same\u0026lt;filelib::result\u0026lt;U\u0026gt;, std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value //  \u0026amp;\u0026amp; std::is_constructible\u0026lt;T, U\u0026gt;::value\u0026gt;\u0026gt; //  constexpr app::outcome\u0026lt;T\u0026gt; operator()(X \u0026amp;\u0026amp;src) { // Forward any successful value  if(src.has_value()) { return {std::forward\u0026lt;X\u0026gt;(src).value()}; } // Synthesise a filesystem_error, exactly as if someone had called src.value()  auto \u0026amp;fi = src.error(); OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(fi.ec); // might throw  return {std::make_exception_ptr(filelib::filesystem_error(fi.ec.message(), std::move(fi.path1), std::move(fi.path2), fi.ec))}; } }; } OUTCOME_V2_NAMESPACE_END View this code on Github Note that the conversion exactly duplicates the implementation of throw_as_system_error_with_payload(failure_info fi) from namespace filelib.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg1/",
	"title": "Phase 3",
	"tags": [],
	"description": "",
	"content": "We have built our first two phases of construction for file_handle, and for some users they might be happy writing:\noutcome::result\u0026lt;file_handle\u0026gt; fh1 = file_handle::file(\u0026#34;hello\u0026#34; /*, file_handle::mode::read */); if(!fh1) { std::cerr \u0026lt;\u0026lt; \u0026#34;Opening file \u0026#39;hello\u0026#39; failed with \u0026#34; \u0026lt;\u0026lt; fh1.error().message() \u0026lt;\u0026lt; std::endl; } View this code on Github \u0026hellip; and be done with it.\nBut wouldn\u0026rsquo;t it be nicer if we could instead write:\noutcome::result\u0026lt;file_handle\u0026gt; fh2 = construct\u0026lt;file_handle\u0026gt;{\u0026#34;hello\u0026#34; /*, file_handle::mode::read */}(); if(!fh2) { std::cerr \u0026lt;\u0026lt; \u0026#34;Opening file \u0026#39;hello\u0026#39; failed with \u0026#34; \u0026lt;\u0026lt; fh2.error().message() \u0026lt;\u0026lt; std::endl; } View this code on Github The eye is immediately drawn to the two-stage invocation pattern, so we are constructing a type construct\u0026lt;file_handle\u0026gt; using the arguments with which we wish to invoke the file_handle constructor with, and then invoking the call operator on that construct\u0026lt;file_handle\u0026gt; instance to do the actual construction.\nWe think that this is a better approach than alternatives, but we shall briefly cover those at the end of this section.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/success_failure/",
	"title": "Success/Failure",
	"tags": [],
	"description": "",
	"content": " Header file success_failure.hpp \nnamespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace policy \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;auto error_code(T\u0026amp;\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;auto exception_ptr(T\u0026amp;\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Error\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;void throw_as_system_error_with_payload(Error\u0026nbsp;const\u0026amp;\u0026nbsp;error); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace trait \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct has_error_code; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;constexpr\u0026nbsp;bool\u0026nbsp;has_error_code_v\u0026nbsp;=\u0026nbsp;has_error_code\u0026lt;T\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct has_exception_ptr; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;constexpr\u0026nbsp;bool\u0026nbsp;has_exception_ptr_v\u0026nbsp;=\u0026nbsp;has_exception_ptr\u0026lt;T\u0026gt;::value; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct success_type; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct success_type\u0026lt;void\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr success_type\u0026lt;void\u0026gt; success()\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr success_type\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt; success(T\u0026amp;\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;EC\u0026nbsp;= std::error_code,\u0026nbsp;class\u0026nbsp;E\u0026nbsp;= void\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct failure_type; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;EC\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct failure_type\u0026lt;EC,\u0026nbsp;void\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;E\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct failure_type\u0026lt;void,\u0026nbsp;E\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;EC\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr failure_type\u0026lt;std::decay_t\u0026lt;EC\u0026gt;\u0026gt; failure(EC\u0026amp;\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr failure_type\u0026lt;std::decay_t\u0026lt;EC\u0026gt;, std::decay_t\u0026lt;E\u0026gt;\u0026gt; failure(EC\u0026amp;\u0026amp;\u0026nbsp;v,\u0026nbsp;E\u0026amp;\u0026amp;\u0026nbsp;w); }  \n\nFunction outcome_v2_xxx::policy::error_code \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;auto\u0026nbsp;error_code(T\u0026amp;\u0026amp;\u0026nbsp;v);  Used by policies to extract a std::error_code from some input T via ADL discovery of some make_error_code(T) function.\nFunction outcome_v2_xxx::policy::exception_ptr \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr\u0026nbsp;auto\u0026nbsp;exception_ptr(T\u0026amp;\u0026amp;\u0026nbsp;v);  Used by policies to extract a std::exception_ptr from some input T via ADL discovery of some make_exception_ptr(T) function.\nFunction outcome_v2_xxx::policy::throw_as_system_error_with_payload \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Error\u0026gt; constexpr\u0026nbsp;void\u0026nbsp;throw_as_system_error_with_payload(Error\u0026nbsp;const\u0026amp;\u0026nbsp;error);  Override to define what the policies which throw a system error with payload ought to do for some particular result.error().\n\nStruct outcome_v2_xxx::trait::has_error_code \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; struct\u0026nbsp;has_error_code { };  Trait for whether a free function make_error_code(T) returning a std::error_code exists or not.\nAlso returns true if std::error_code is convertible from T.\nUnexposed entity outcome_v2_xxx::trait::has_error_code_v \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;constexpr\u0026nbsp;bool\u0026nbsp;has_error_code_v\u0026nbsp;=\u0026nbsp;has_error_code\u0026lt;T\u0026gt;::value;  Trait for whether a free function make_error_code(T) returning a std::error_code exists or not.\nAlso returns true if std::error_code is convertible from T.\nStruct outcome_v2_xxx::trait::has_exception_ptr \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; struct\u0026nbsp;has_exception_ptr { };  Trait for whether a free function make_exception_ptr(T) returning a std::exception_ptr exists or not.\nAlso returns true if std::exception_ptr is convertible from T.\nUnexposed entity outcome_v2_xxx::trait::has_exception_ptr_v \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt;constexpr\u0026nbsp;bool\u0026nbsp;has_exception_ptr_v\u0026nbsp;=\u0026nbsp;has_exception_ptr\u0026lt;T\u0026gt;::value;  Trait for whether a free function make_exception_ptr(T) returning a std::exception_ptr exists or not.\nAlso returns true if std::exception_ptr is convertible from T.\nStruct outcome_v2_xxx::success_type \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; struct\u0026nbsp;success_type { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using value_type\u0026nbsp;=\u0026nbsp;T; \u0026#x2F;\u0026#x2F;=== Default, copy\u0026#x2F;move constructors and assignment ===\u0026#x2F;\u0026#x2F; success_type()\u0026nbsp;=\u0026nbsp;default; success_type(const success_type\u0026lt;T\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; success_type(success_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; success_type\u0026lt;T\u0026gt;\u0026amp; operator=(const success_type\u0026lt;T\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; success_type\u0026lt;T\u0026gt;\u0026amp; operator=(success_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; ~success_type()\u0026nbsp;=\u0026nbsp;default; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;typename\u0026nbsp;= std::enable_if_t\u0026lt;!std::is_same\u0026lt;success_type,std::decay_t\u0026lt;U\u0026gt;\u0026gt;::value\u0026gt;\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr success_type(U\u0026amp;\u0026amp;\u0026nbsp;v); \u0026#x2F;\u0026#x2F;=== success_type_value ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr value_type\u0026amp; value()\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr value_type\u0026amp; value()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr value_type\u0026amp;\u0026amp; value()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr value_type\u0026amp;\u0026amp; value()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; };  Type sugar for implicitly constructing a result\u0026lt;\u0026gt; with a successful state.\nType alias outcome_v2_xxx::success_type::value_type \nusing\u0026nbsp;value_type\u0026nbsp;=\u0026nbsp;T;  The type of the successful state.\nConstructor outcome_v2_xxx::success_type::success_type \nsuccess_type()\u0026nbsp;=\u0026nbsp;default;  Default constructor\nConstructor outcome_v2_xxx::success_type::success_type \nsuccess_type(const success_type\u0026lt;T\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy constructor\nConstructor outcome_v2_xxx::success_type::success_type \nsuccess_type(success_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move constructor\nFunction outcome_v2_xxx::success_type::operator= \nsuccess_type\u0026lt;T\u0026gt;\u0026amp;\u0026nbsp;operator=(const success_type\u0026lt;T\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy assignment\nFunction outcome_v2_xxx::success_type::operator= \nsuccess_type\u0026lt;T\u0026gt;\u0026amp;\u0026nbsp;operator=(success_type\u0026lt;T\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move assignment\nDestructor outcome_v2_xxx::success_type::~success_type \n~success_type()\u0026nbsp;=\u0026nbsp;default;  Destructor\nConstructor outcome_v2_xxx::success_type::success_type \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;typename\u0026nbsp;= std::enable_if_t\u0026lt;!std::is_same\u0026lt;success_type,std::decay_t\u0026lt;U\u0026gt;\u0026gt;::value\u0026gt;\u0026gt; constexpr\u0026nbsp;success_type(U\u0026amp;\u0026amp;\u0026nbsp;v);  Initialising constructor\nRequires: That U is not success_type.\nFunction outcome_v2_xxx::success_type::value \n(1)\u0026nbsp;constexpr value_type\u0026amp;\u0026nbsp;value()\u0026nbsp;\u0026amp;; (2)\u0026nbsp;constexpr value_type\u0026amp;\u0026nbsp;value()\u0026nbsp;const\u0026nbsp;\u0026amp;; (3)\u0026nbsp;constexpr value_type\u0026amp;\u0026amp;\u0026nbsp;value()\u0026nbsp;\u0026amp;\u0026amp;; (4)\u0026nbsp;constexpr value_type\u0026amp;\u0026amp;\u0026nbsp;value()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;;  Access value.\nReturns: Reference to the held value_type according to overload.\nStruct outcome_v2_xxx::success_type \ntemplate\u0026nbsp;\u0026lt;\u0026gt; struct success_type\u0026lt;void\u0026gt; { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using value_type\u0026nbsp;=\u0026nbsp;void; };  Type sugar for implicitly constructing a result\u0026lt;\u0026gt; with a successful state.\nType alias outcome_v2_xxx::success_type::value_type \nusing\u0026nbsp;value_type\u0026nbsp;=\u0026nbsp;void;  The type of the successful state.\nFunction outcome_v2_xxx::success \nconstexpr success_type\u0026lt;void\u0026gt;\u0026nbsp;success()\u0026nbsp;noexcept;  Returns type sugar for implicitly constructing a result\u0026lt;T\u0026gt; with a successful state, default constructing T if necessary.\nFunction outcome_v2_xxx::success \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T\u0026gt; constexpr success_type\u0026lt;std::decay_t\u0026lt;T\u0026gt;\u0026gt;\u0026nbsp;success(T\u0026amp;\u0026amp;\u0026nbsp;v);  Returns type sugar for implicitly constructing a result\u0026lt;T\u0026gt; with a successful state.\nEffects: Copies or moves the successful state supplied into the returned type sugar.\nStruct outcome_v2_xxx::failure_type \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;EC\u0026nbsp;= std::error_code,\u0026nbsp;class\u0026nbsp;E\u0026nbsp;= void\u0026gt; struct\u0026nbsp;failure_type { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using error_type\u0026nbsp;=\u0026nbsp;EC; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using exception_type\u0026nbsp;=\u0026nbsp;E; \u0026#x2F;\u0026#x2F;=== Default, copy\u0026#x2F;move constructors and assignment ===\u0026#x2F;\u0026#x2F; failure_type()\u0026nbsp;=\u0026nbsp;default; failure_type(const failure_type\u0026lt;EC, E\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; failure_type(failure_type\u0026lt;EC, E\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; failure_type\u0026lt;EC, E\u0026gt;\u0026amp; operator=(const failure_type\u0026lt;EC, E\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; failure_type\u0026lt;EC, E\u0026gt;\u0026amp; operator=(failure_type\u0026lt;EC, E\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; ~failure_type()\u0026nbsp;=\u0026nbsp;default; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr failure_type(U\u0026amp;\u0026amp;\u0026nbsp;u,\u0026nbsp;V\u0026amp;\u0026amp;\u0026nbsp;v); \u0026#x2F;\u0026#x2F;=== failure_type_error ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr error_type\u0026amp; error()\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr error_type\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr error_type\u0026amp;\u0026amp; error()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr error_type\u0026amp;\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; \u0026#x2F;\u0026#x2F;=== failure_type_exception ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr exception_type\u0026amp; exception()\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr exception_type\u0026amp; exception()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr exception_type\u0026amp;\u0026amp; exception()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr exception_type\u0026amp;\u0026amp; exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; };  Type sugar for implicitly constructing a result\u0026lt;\u0026gt; with a failure state of error code and exception.\nType alias outcome_v2_xxx::failure_type::error_type \nusing\u0026nbsp;error_type\u0026nbsp;=\u0026nbsp;EC;  The type of the error code\nType alias outcome_v2_xxx::failure_type::exception_type \nusing\u0026nbsp;exception_type\u0026nbsp;=\u0026nbsp;E;  The type of the exception\nConstructor outcome_v2_xxx::failure_type::failure_type \nfailure_type()\u0026nbsp;=\u0026nbsp;default;  Default constructor\nConstructor outcome_v2_xxx::failure_type::failure_type \nfailure_type(const failure_type\u0026lt;EC, E\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy constructor\nConstructor outcome_v2_xxx::failure_type::failure_type \nfailure_type(failure_type\u0026lt;EC, E\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move constructor\nFunction outcome_v2_xxx::failure_type::operator= \nfailure_type\u0026lt;EC, E\u0026gt;\u0026amp;\u0026nbsp;operator=(const failure_type\u0026lt;EC, E\u0026gt;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy assignment\nFunction outcome_v2_xxx::failure_type::operator= \nfailure_type\u0026lt;EC, E\u0026gt;\u0026amp;\u0026nbsp;operator=(failure_type\u0026lt;EC, E\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move assignment\nDestructor outcome_v2_xxx::failure_type::~failure_type \n~failure_type()\u0026nbsp;=\u0026nbsp;default;  Destructor\nConstructor outcome_v2_xxx::failure_type::failure_type \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;class\u0026nbsp;V\u0026gt; constexpr\u0026nbsp;failure_type(U\u0026amp;\u0026amp;\u0026nbsp;u,\u0026nbsp;V\u0026amp;\u0026amp;\u0026nbsp;v);  Initialising constructor\nFunction outcome_v2_xxx::failure_type::error \n(1)\u0026nbsp;constexpr error_type\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;; (2)\u0026nbsp;constexpr error_type\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;; (3)\u0026nbsp;constexpr error_type\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;\u0026amp;; (4)\u0026nbsp;constexpr error_type\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;;  Access error.\nReturns: Reference to the held error_type according to overload.\nFunction outcome_v2_xxx::failure_type::exception \n(1)\u0026nbsp;constexpr exception_type\u0026amp;\u0026nbsp;exception()\u0026nbsp;\u0026amp;; (2)\u0026nbsp;constexpr exception_type\u0026amp;\u0026nbsp;exception()\u0026nbsp;const\u0026nbsp;\u0026amp;; (3)\u0026nbsp;constexpr exception_type\u0026amp;\u0026amp;\u0026nbsp;exception()\u0026nbsp;\u0026amp;\u0026amp;; (4)\u0026nbsp;constexpr exception_type\u0026amp;\u0026amp;\u0026nbsp;exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;;  Access exception.\nReturns: Reference to the held exception_type according to overload.\nStruct outcome_v2_xxx::failure_type \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;EC\u0026gt; struct failure_type\u0026lt;EC,\u0026nbsp;void\u0026gt; { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using error_type\u0026nbsp;=\u0026nbsp;EC; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using exception_type\u0026nbsp;=\u0026nbsp;void; \u0026#x2F;\u0026#x2F;=== Default, copy\u0026#x2F;move constructors and assignment ===\u0026#x2F;\u0026#x2F; failure_type()\u0026nbsp;=\u0026nbsp;default; failure_type(failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026nbsp;const\u0026amp;)\u0026nbsp;=\u0026nbsp;default; failure_type(failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026amp; operator=(failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026nbsp;const\u0026amp;)\u0026nbsp;=\u0026nbsp;default; failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026amp; operator=(failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; ~failure_type()\u0026nbsp;=\u0026nbsp;default; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;typename\u0026nbsp;= std::enable_if_t\u0026lt;!std::is_same\u0026lt;failure_type,std::decay_t\u0026lt;U\u0026gt;\u0026gt;::value\u0026gt;\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr failure_type(U\u0026amp;\u0026amp;\u0026nbsp;u); \u0026#x2F;\u0026#x2F;=== failure_type_error2 ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr error_type\u0026amp; error()\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr error_type\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr error_type\u0026amp;\u0026amp; error()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr error_type\u0026amp;\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; };  Type sugar for implicitly constructing a result\u0026lt;\u0026gt; with a failure state of error code.\nType alias outcome_v2_xxx::failure_type::error_type \nusing\u0026nbsp;error_type\u0026nbsp;=\u0026nbsp;EC;  The type of the error code\nType alias outcome_v2_xxx::failure_type::exception_type \nusing\u0026nbsp;exception_type\u0026nbsp;=\u0026nbsp;void;  The type of the exception\nConstructor outcome_v2_xxx::failure_type::failure_type \nfailure_type()\u0026nbsp;=\u0026nbsp;default;  Default constructor\nConstructor outcome_v2_xxx::failure_type::failure_type \nfailure_type(failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026nbsp;const\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy constructor\nConstructor outcome_v2_xxx::failure_type::failure_type \nfailure_type(failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move constructor\nFunction outcome_v2_xxx::failure_type::operator= \nfailure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026amp;\u0026nbsp;operator=(failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026nbsp;const\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy assignment\nFunction outcome_v2_xxx::failure_type::operator= \nfailure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026amp;\u0026nbsp;operator=(failure_type\u0026lt;type-parameter-0-0, void\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move assignment\nDestructor outcome_v2_xxx::failure_type::~failure_type \n~failure_type()\u0026nbsp;=\u0026nbsp;default;  Destructor\nConstructor outcome_v2_xxx::failure_type::failure_type \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;U,\u0026nbsp;typename\u0026nbsp;= std::enable_if_t\u0026lt;!std::is_same\u0026lt;failure_type,std::decay_t\u0026lt;U\u0026gt;\u0026gt;::value\u0026gt;\u0026gt; constexpr\u0026nbsp;failure_type(U\u0026amp;\u0026amp;\u0026nbsp;u);  Initialising constructor\nRequires: That U is not failure_type.\nFunction outcome_v2_xxx::failure_type::error \n(1)\u0026nbsp;constexpr error_type\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;; (2)\u0026nbsp;constexpr error_type\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;; (3)\u0026nbsp;constexpr error_type\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;\u0026amp;; (4)\u0026nbsp;constexpr error_type\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;;  Access error.\nReturns: Reference to the held error_type according to overload.\nStruct outcome_v2_xxx::failure_type \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;E\u0026gt; struct failure_type\u0026lt;void,\u0026nbsp;E\u0026gt; { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using error_type\u0026nbsp;=\u0026nbsp;void; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;using exception_type\u0026nbsp;=\u0026nbsp;E; \u0026#x2F;\u0026#x2F;=== Default, copy\u0026#x2F;move constructors and assignment ===\u0026#x2F;\u0026#x2F; failure_type()\u0026nbsp;=\u0026nbsp;default; failure_type(failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026nbsp;const\u0026amp;)\u0026nbsp;=\u0026nbsp;default; failure_type(failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026amp; operator=(failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026nbsp;const\u0026amp;)\u0026nbsp;=\u0026nbsp;default; failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026amp; operator=(failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default; ~failure_type()\u0026nbsp;=\u0026nbsp;default; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;V,\u0026nbsp;typename\u0026nbsp;= std::enable_if_t\u0026lt;!std::is_same\u0026lt;failure_type,std::decay_t\u0026lt;V\u0026gt;\u0026gt;::value\u0026gt;\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr failure_type(V\u0026amp;\u0026amp;\u0026nbsp;v); \u0026#x2F;\u0026#x2F;=== failure_type_exception2 ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr exception_type\u0026amp; exception()\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr exception_type\u0026amp; exception()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr exception_type\u0026amp;\u0026amp; exception()\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr exception_type\u0026amp;\u0026amp; exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; };  Type sugar for implicitly constructing a result\u0026lt;\u0026gt; with a failure state of exception.\nType alias outcome_v2_xxx::failure_type::error_type \nusing\u0026nbsp;error_type\u0026nbsp;=\u0026nbsp;void;  The type of the error code\nType alias outcome_v2_xxx::failure_type::exception_type \nusing\u0026nbsp;exception_type\u0026nbsp;=\u0026nbsp;E;  The type of the exception\nConstructor outcome_v2_xxx::failure_type::failure_type \nfailure_type()\u0026nbsp;=\u0026nbsp;default;  Default constructor\nConstructor outcome_v2_xxx::failure_type::failure_type \nfailure_type(failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026nbsp;const\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy constructor\nConstructor outcome_v2_xxx::failure_type::failure_type \nfailure_type(failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move constructor\nFunction outcome_v2_xxx::failure_type::operator= \nfailure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026amp;\u0026nbsp;operator=(failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026nbsp;const\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Copy assignment\nFunction outcome_v2_xxx::failure_type::operator= \nfailure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026amp;\u0026nbsp;operator=(failure_type\u0026lt;void, type-parameter-0-0\u0026gt;\u0026amp;\u0026amp;)\u0026nbsp;=\u0026nbsp;default;  Move assignment\nDestructor outcome_v2_xxx::failure_type::~failure_type \n~failure_type()\u0026nbsp;=\u0026nbsp;default;  Destructor\nConstructor outcome_v2_xxx::failure_type::failure_type \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;V,\u0026nbsp;typename\u0026nbsp;= std::enable_if_t\u0026lt;!std::is_same\u0026lt;failure_type,std::decay_t\u0026lt;V\u0026gt;\u0026gt;::value\u0026gt;\u0026gt; constexpr\u0026nbsp;failure_type(V\u0026amp;\u0026amp;\u0026nbsp;v);  Initialising constructor\nRequires: That V is not failure_type.\nFunction outcome_v2_xxx::failure_type::exception \n(1)\u0026nbsp;constexpr exception_type\u0026amp;\u0026nbsp;exception()\u0026nbsp;\u0026amp;; (2)\u0026nbsp;constexpr exception_type\u0026amp;\u0026nbsp;exception()\u0026nbsp;const\u0026nbsp;\u0026amp;; (3)\u0026nbsp;constexpr exception_type\u0026amp;\u0026amp;\u0026nbsp;exception()\u0026nbsp;\u0026amp;\u0026amp;; (4)\u0026nbsp;constexpr exception_type\u0026amp;\u0026amp;\u0026nbsp;exception()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;;  Access exception.\nReturns: Reference to the held exception_type according to overload.\nFunction outcome_v2_xxx::failure \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;EC\u0026gt; constexpr failure_type\u0026lt;std::decay_t\u0026lt;EC\u0026gt;\u0026gt;\u0026nbsp;failure(EC\u0026amp;\u0026amp;\u0026nbsp;v);  Returns type sugar for implicitly constructing a result\u0026lt;T\u0026gt; with a failure state.\nEffects: Copies or moves the failure state supplied into the returned type sugar.\nFunction outcome_v2_xxx::failure \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; constexpr failure_type\u0026lt;std::decay_t\u0026lt;EC\u0026gt;, std::decay_t\u0026lt;E\u0026gt;\u0026gt;\u0026nbsp;failure(EC\u0026amp;\u0026amp;\u0026nbsp;v,\u0026nbsp;E\u0026amp;\u0026amp;\u0026nbsp;w);  Returns type sugar for implicitly constructing a result\u0026lt;T\u0026gt; with a failure state.\nEffects: Copies or moves the failure state supplied into the returned type sugar.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/variations/",
	"title": "Variations",
	"tags": [],
	"description": "",
	"content": "You can of course choose your own E type so long as it has standard layout and is trivially copyable. You would declare that with  CXX_DECLARE_RESULT(t_ident, t_decl, e_ident, e_decl) , refer to it with  CXX_RESULT(t_ident, e_ident) and need to do your own decoding of errors from your E type. By using the _EC postfixed macros, you are in fact using E =\nstruct cxx_error_code { int code; void *category; }; \u0026hellip; which is declared for you by result.h.\nOutcome\u0026rsquo;s C support was designed assuming that you do not wish to penalise the performance of C++ code calling these C-compatible C++ functions, but if you don\u0026rsquo;t care about that, then always setting errno to any error in a result\u0026lt;T\u0026gt; is easily implemented and thus the natural C use pattern becomes available:\nextern size_t to_string(char *buffer, size_t bufferlen, int v); ... size_t len = to_string(buffer, sizeof(buffer), v); if(errno != 0) ... Implementing this via boilerplate generating script is straightforward, and is left as an exercise to the interested reader.\n"
},
{
	"uri": "https://ned14.github.io/outcome/videos/",
	"title": "Videos",
	"tags": [],
	"description": "",
	"content": " Outcome has been presented at some of the major C++ conferences as it has evolved. As the older content is less relevant to Outcome today, this list is given in reverse chronological order.\nMeeting C++ 2017 \u0026ldquo;Introduction to proposed std::expected\u0026lt;T, E\u0026gt;\u0026ldquo; Literature review of the several WG21 papers relating to std::expected.\n   ACCU 2017 \u0026ldquo;Mongrel Monads, Dirty, dirty, dirty\u0026rdquo; Covers the history of error handling in C++, and how the LEWG Expected works.\n(Note that the Expected presented here no longer exists, it was substantially changed after the Outcome v1 peer review. Furthermore the Outcome presented here no longer exists, the peer review demanded a complete rebuild)\n   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/exception-ptr/",
	"title": "exception_ptr",
	"tags": [],
	"description": "",
	"content": "Another default action exists for result\u0026lt;T, EC\u0026gt; where trait::has_exception_ptr\u0026lt;EC\u0026gt; is true, and for outcome\u0026lt;T, EC, EP\u0026gt; where either or both trait::has_exception_ptr\u0026lt;EC\u0026gt; and trait::has_exception_ptr\u0026lt;EP\u0026gt; is true.\nThis default action simply rethrows the exception pointer via std::rethrow_exception(make_exception_ptr(.error())) for result and std::rethrow_exception(make_exception_ptr(.error())) and/or std::rethrow_exception(make_exception_ptr(.exception())) for outcome, if trait::has_exception_ptr\u0026lt;EC\u0026gt; and/or trait::has_exception_ptr\u0026lt;EP\u0026gt; is true.\nstruct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; result\u0026lt;udt, std::exception_ptr\u0026gt; res(std::make_exception_ptr(std::runtime_error(\u0026#34;hello\u0026#34;))); // What happens here? What exception type is thrown?  try { std::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl; } catch(const std::exception \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } View this code on Github Running this yields:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_exception_ptr Exception thrown was hello ned@lyta:~/outcome/build_posix$  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/outcome_exception_ptr_rethrow/",
	"title": "exception_ptr rethrow (Outcome)",
	"tags": [],
	"description": "",
	"content": " Header file outcome_exception_ptr_rethrow.hpp \n#include\u0026nbsp;\u0026quot;result_exception_ptr_rethrow.hpp\u0026quot; namespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace\u0026nbsp;policy \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct exception_ptr_rethrow; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} }  \n\nStruct outcome_v2_xxx::policy::exception_ptr_rethrow \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; struct\u0026nbsp;exception_ptr_rethrow { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; };  Policy interpreting EC or E as a type for which trait::has_exception_ptr_v\u0026lt;EC|E\u0026gt; is true.\nAny wide attempt to access the successful state where there is none causes: std::rethrow_exception(policy::exception_ptr(.error()|.exception())) appropriately.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::exception_ptr_rethrow::wide_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the value() functions\nEffects: If outcome does not have a value, if it has an exception it rethrows that exception via std::rethrow_exception(), if it has an error it rethrows that error via std::rethrow_exception(), else it throws bad_outcome_access.\nFunction outcome_v2_xxx::policy::exception_ptr_rethrow::wide_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the error() functions\nEffects: If outcome does not have an error, it throws bad_outcome_access.\nFunction outcome_v2_xxx::policy::exception_ptr_rethrow::wide_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the exception() functions\nEffects: If result does not have an exception, it throws bad_outcome_access.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/",
	"title": "Default actions",
	"tags": ["default-actions"],
	"description": "The default rules for handling different categories of failure type",
	"content": "In the last section, we observed with .value() the value of the outcome returned by copy_file() and saw that it may throw a C++ exception configured by an ADL discovered function. This behaviour is what we will call a \u0026ldquo;default action\u0026rdquo; i.e. a pre-programmed action taken by Outcome in response to no-value observation.\nSome \u0026ndash; strongly \u0026ndash; feel that these value-or-error objects should not have any \u0026ldquo;default action\u0026rdquo; other than to throw a special exception carrying as payload the cause of the no-value i.e. the error. Most with this opinion feel that the \u0026ldquo;default action\u0026rdquo; is in fact to unwind the stack, and that using an exception throw instead of a function return is basically the same thing precisely because a stack unwind occurs in both cases, and the mechanism by which that is achieved isn\u0026rsquo;t particularly important. Indeed, the Expected proposal before WG21, which intends to standardise a value-or-error object not dissimilar to Outcome\u0026rsquo;s objects, does just this (at the time of writing). Optional, which is a value-or-nothing object, similarly throws a special exception on no-value observation via .value().\nOutcome\u0026rsquo;s default is to not provide value-or-error objects. It provides success-or-failure objects. We define the difference as being \u0026ldquo;having programmable actions in response to no-value observation other than throwing a hard coded logic error type exception1\u0026rdquo;. This philosophical difference implies that throwing a C++ exception is solely used to abort the current operation with a useful-to-the-programmer default action, not as a control flow alternative to ordinary returns from function, not for reporting \u0026ldquo;recoverable\u0026rdquo; logic errors.\nYou can, of course, choose different default actions for your particular Outcome instance, implement your own default actions, and indeed configure a result and outcome which throw a logic error type exception exactly the same way as Expected or Optional does. How to do this is described later in this tutorial.\nThis section describes the default actions implemented by Outcome, which we believe will cover the large majority of users with no further configuration needed.\n I take exception to throwing logic error type exceptions as is unfortunately the case throughout the C++ standard library. What actual value to the programmer do they deliver? If used as control flow, then there are always much superior alternatives. If used for spotting a true logic error, then you just detected bad logic by the programmer or memory corruption, in which case this situation is not recoverable and you really ought to fatal exit. And then consider all the many negatives: (i) you force programmers to have to deal with exception safety, substantially increasing development costs for virtually no gain to the programmer (ii) you force the compiler to have to deal with potential exception throws, slowing down compile times and generating bloatier code just in case something which should almost never happen might occur (iii) analysis tooling can\u0026rsquo;t tell between control flow and logic error type exception throws, and thus cannot spot nor warn you when you didn\u0026rsquo;t mean them to occur.On table-based exception handling implementations, throwing an exception is assumed to be extremely rare. This allows zero performance impact on the non-throwing code paths, but at a very severe performance cost to any time that you throw and catch an exception. This is unavoidable in any table-based exception handling implementation. A throw...catch cycle is always at least thousands of times more expensive than a return statement, and always must be so, even when the throw...catch is inlined on current compiler technology. [return]   "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-map-tidylib/",
	"title": "Mapping the HTMLTidy library into the Application",
	"tags": [],
	"description": "",
	"content": "Once again, we create a custom STL exception type to represent failure from the HTMLTidy library. We also create an app namespace wrapper for the C tidy_html() function which is more C++ friendly.\nnamespace app { // Specialise an exception type for tidylib errors  struct tidylib_error : std::system_error { // passthrough  using std::system_error::system_error; tidylib_error() = default; explicit tidylib_error(int c) : std::system_error(c, std::generic_category()) { } }; // Create a C++ invoking wrapper for the tidylib C API, modifying data with the returned data,  // returing a unique_ptr to release storage on scope exit.  struct call_free { template \u0026lt;class T\u0026gt; void operator()(T *p) { ::free(p); } }; inline outcome\u0026lt;std::unique_ptr\u0026lt;char, call_free\u0026gt;\u0026gt; tidy_html(string_view \u0026amp;data) { char *out = nullptr; size_t outlen = 0; int errcode = ::tidy_html(\u0026amp;out, \u0026amp;outlen, data.data(), data.size()); if(errcode != 0) { // If the error code matches a standard STL exception, throw as that.  OUTCOME_V2_NAMESPACE::try_throw_std_exception_from_error(std::error_code(errcode, std::generic_category())); // Otherwise wrap the error code into a tidylib_error exception throw  return std::make_exception_ptr(tidylib_error(errcode)); } // Reset input view to tidied html  data = string_view(out, outlen); // Return a unique ptr to release storage on scope exit  return std::unique_ptr\u0026lt;char, call_free\u0026gt;(out); } } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/",
	"title": "Result returning constructors",
	"tags": ["constructors"],
	"description": "How to metaprogram construction of objects which use result&lt;T, EC&gt; to return failure instead of throwing a C++ exception.",
	"content": "An oft asked question during conference talks on Expected/Outcome is how to exclusively use result to implement constructor failure. This is asked because whilst almost every member function in a class can return a result, constructors do not return values and thus cannot return a result. The implication is that one cannot avoid throwing C++ exceptions to abort a construction.\nAs with most things in C++, one can achieve zero-exception-throw object construction using a lot of extra typing of boilerplate, and a little bit of simple C++ metaprogramming. This section shows you how to implement these for those who are absolutely adverse to ever throwing an exception, or cannot because C++ exceptions have been globally disabled.\nThe technique described here is not suitable for non-copyable and non-movable types. There is also an assumption that moving your type is cheap.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/hook_outcome/",
	"title": "Hook outcome",
	"tags": [],
	"description": "",
	"content": "The final step is to add ADL discovered event hooks for the very specific case of when our localised outcome is copy or move constructed from our localised result. There isn\u0026rsquo;t really much to say about these, just be careful to mark them noexcept or not based on whether the types T, EC or EP could throw during copy or move construction. As poke_exception() creates a std::string and appends to it, it could indeed throw an exception and thus with the noexcept hooks below, the process would be terminated.\nnamespace error_code_extended { // Specialise the outcome copy and move conversion hook for when our localised result  // is used as the source for copy construction our localised outcome  template \u0026lt;class T, class U\u0026gt; inline void hook_outcome_copy_construction(outcome\u0026lt;T\u0026gt; *res, const result\u0026lt;U\u0026gt; \u0026amp; /*unused*/) noexcept { // when copy constructing from a result\u0026lt;T\u0026gt;, poke in an exception  poke_exception(res); } template \u0026lt;class T, class U\u0026gt; inline void hook_outcome_move_construction(outcome\u0026lt;T\u0026gt; *res, result\u0026lt;U\u0026gt; \u0026amp;\u0026amp; /*unused*/) noexcept { // when move constructing from a result\u0026lt;T\u0026gt;, poke in an exception  poke_exception(res); } } View this code on Github "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/hooks/",
	"title": "Hooking events",
	"tags": ["hooks"],
	"description": "Intercepting useful events such as initial construction, copies and moves so you can capture backtraces, fire debug breakpoints etc.",
	"content": "Outcome provides multiple methods for user code to intercept various events which occur. The deepest is simply to inherit from result or outcome and override member functions, for which you will need to study the source code as that form of customisation is out of scope for this tutorial. Another option is to supply a custom NoValuePolicy (see next section). The final option, which this section covers, is to use the ADL discovered event hooks which tell you when a namespace-localised outcome or result has been:\n Constructed   hook_result_construction(result\u0026lt;T, E\u0026gt; *this, U \u0026amp;\u0026amp;src)   hook_outcome_construction(outcome\u0026lt;T, EC, EP\u0026gt; *this, U \u0026amp;\u0026amp;src)   In-place constructed   hook_result_in_place_construction(result\u0026lt;T, E\u0026gt; *this, in_place_type_t\u0026lt;T|E\u0026gt;, Args\u0026amp;\u0026amp;... srcs)   hook_outcome_in_place_construction(outcome\u0026lt;T, EC, EP\u0026gt; *this, in_place_type_t\u0026lt;T|EC|EP\u0026gt;, Args\u0026amp;\u0026amp;... srcs)   Copied   hook_result_copy_construction(result\u0026lt;T, E\u0026gt; *this, U \u0026amp;\u0026amp;src)   hook_outcome_copy_construction(outcome\u0026lt;T, EC, EP\u0026gt; *this, U \u0026amp;\u0026amp;src)   Moved   hook_result_move_construction(result\u0026lt;T, E\u0026gt; *this, U \u0026amp;\u0026amp;src)   hook_outcome_move_construction(outcome\u0026lt;T, EC, EP\u0026gt; *this, U \u0026amp;\u0026amp;src)    One criticism often levelled against these success-or-failure objects is that they do not provide as rich a set of facilities as C++ exception throws. This section shows you how to configure Outcome using the ADL event hooks to take a stack backtrace on construction of an errored result\u0026lt;T, error_code\u0026gt;, and if that result\u0026lt;T, error_code\u0026gt; should ever be converted into an outcome\u0026lt;T, error_code, std::exception_ptr\u0026gt;, a custom std::exception_ptr will be just-in-time synthesised consisting of the std::system_error for the error code, plus an expanded message string containing the stack backtrace of where the error originally occurred. One can see the use case for fixed latency code being built with result, and it dovetailing into application code where execution time guarantees are not important where a malloc is permitted.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/app-go/",
	"title": "In use",
	"tags": [],
	"description": "",
	"content": "This is how you might now write application code using these three libraries:\nnamespace app { outcome\u0026lt;void\u0026gt; go() // NOT noexcept, this can throw STL exceptions e.g. bad_alloc  { // Note that explicit construction is required when converting between differing types  // of outcome and result. This makes it explicit what you intend to do as conversion  // may be a lot more expensive than moves.  // Try to GET this URL. If an unsuccessful HTTP status is returned, serialise a string  // containing a description of the HTTP status code and the URL which failed, storing  // that into a httplib_error exception type which is stored as an exception ptr. The  // TRY operation below will return that exception ptr to be rethrown in the caller.  // Otherwise the fetched data is returned in a std::string data.  OUTCOME_TRY(data, (outcome\u0026lt;std::string\u0026gt;(httplib::get(\u0026#34;http://www.nedproductions.biz/\u0026#34;)))); string_view data_view(data); // HTML tidy the fetched data. If the C library fails due to an error corresponding to  // a standard library exception type, throw that. Otherwise, synthesise an exception  // ptr of type tidylib_error which stores the error code returned in an error code with  // generic category (i.e. errno domain).  // TRY operation below will return that exception ptr to be rethrown in the caller.  // Otherwise the tidied data is returned into holdmem, with the string view updated to  // point at the tidied data.  OUTCOME_TRY(holdmem, (tidy_html(data_view))); // Write the tidied data to some file. If the write fails, synthesise a filesystem_error  // exception ptr exactly as if one called filelib::write_file(data_view).value().  OUTCOME_TRY(written, (outcome\u0026lt;size_t\u0026gt;(filelib::write_file(data_view)))); return success(); } } View this code on Github Many will wish that the explicit converting wrappers around third party library APIs were not there. Note that in C++ 17 you should be able to dispense with the angle bracketed type as the compiler can now deduce that. But one must still wrap all third party API invocations with outcome() i.e. explicit construction to namespace-localised outcome. This is a deliberate design decision: in Outcome, all converting construction is always explicit, except when the source is success or failure type sugar. And down the line when others come to maintain this code, we think it will be very useful to be explicit on this because user defined code that we customised earlier is being executed.\nNote also that we are able to use TRY throughout this function, and most especially note that we never, at any stage, needed to modify the source code of httplib, tidylib nor filelib, or inject custom things into their namespaces. This entire worked example was achieved solely by app based customisation points and via convert.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/utils/",
	"title": "Utilities",
	"tags": [],
	"description": "",
	"content": " Header file utils.hpp \nnamespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::error_code error_from_exception(std::exception_ptr\u0026amp;\u0026amp; ep\u0026nbsp;=\u0026nbsp;std::current_exception(,\u0026nbsp;std::error_code not_matched\u0026nbsp;=\u0026nbsp;std::make_error_code(std::errc::resource_unavailable_try_again)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;void try_throw_std_exception_from_error(std::error_code ec,\u0026nbsp;std::string\u0026nbsp;const\u0026amp; msg\u0026nbsp;=\u0026nbsp;std::string{); }  \nFunction outcome_v2_xxx::error_from_exception \nstd::error_code\u0026nbsp;error_from_exception(std::exception_ptr\u0026amp;\u0026amp; ep\u0026nbsp;=\u0026nbsp;std::current_exception(,\u0026nbsp;std::error_code not_matched\u0026nbsp;=\u0026nbsp;std::make_error_code(std::errc::resource_unavailable_try_again)\u0026nbsp;noexcept;  Utility function which tries to match the exception in the pointer provided to an equivalent error code. Ought to work for all standard STL types.\nEffects: Rethrows the exception in the pointer, and via a long sequence of catch clauses attempts to match the equivalent error code. If a match is found, the pointer is reset to null. If a match is not found, not_matched is returned instead and the pointer is left unmodified.\nParameters  ep \u0026mdash; The pointer to an exception to convert. If matched, on exit this is reset to a null pointer.  Parameter outcome_v2_xxx::not_matched \nstd::error_code\u0026nbsp;not_matched\u0026nbsp;=\u0026nbsp;std::make_error_code(std::errc::resource_unavailable_try_again The error code to return if we could not match the exception.\nNote that a null pointer in returns a null error code.\nFunction outcome_v2_xxx::try_throw_std_exception_from_error \nvoid\u0026nbsp;try_throw_std_exception_from_error(std::error_code ec,\u0026nbsp;std::string\u0026nbsp;const\u0026amp; msg\u0026nbsp;=\u0026nbsp;std::string{);  Utility function which tries to throw the equivalent STL exception type for some given error code, not including system_error.\nEffects: If the input error code has a category of generic_category() (all platforms) or system_category() (POSIX only), throw the STL exception type matching the errno domained code if one is available. For example, ENOMEM would cause std::bad_alloc() to be thrown.\nParameters  ec \u0026mdash; The error code to try to convert into a STL exception throw. msg \u0026mdash; Optional custom message for the STL exception type.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg2/",
	"title": "construct&lt;T&gt;",
	"tags": [],
	"description": "",
	"content": "First, we need a base definition for construct\u0026lt;T\u0026gt;:\ntemplate \u0026lt;class T\u0026gt; struct construct { outcome::result\u0026lt;T\u0026gt; operator()() const noexcept { //  static_assert(!std::is_same\u0026lt;T, T\u0026gt;::value, \u0026#34;construct\u0026lt;T\u0026gt;() was not specialised for the type T supplied\u0026#34;); } }; View this code on Github This fails a static assert if the type is ever instantiated unspecialised.\nWe then specialise for construct\u0026lt;file_handle\u0026gt;:\ntemplate \u0026lt;\u0026gt; struct construct\u0026lt;file_handle\u0026gt; { file_handle::path_type _path; file_handle::mode _mode{file_handle::mode::read}; // Any other args, default initialised if necessary, follow here ...  outcome::result\u0026lt;file_handle\u0026gt; operator()() const noexcept { return file_handle::file(std::move(_path)); } }; View this code on Github Because this is a struct, we can list initialise construct, and use default member initialisers to implement default arguments. This can get you surprisingly far before you need to start writing custom constructors.\nBut in more complex code, you will usually provide all the initialisation overloads that you would for the constructors of your main type. You then implement a single phase 2 constructing function which accepts construct\u0026lt;YOURTYPE\u0026gt; as input, and construct solely from that source.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/result_exception_ptr_rethrow/",
	"title": "exception_ptr rethrow (Result)",
	"tags": [],
	"description": "",
	"content": " Header file result_exception_ptr_rethrow.hpp \n#include\u0026nbsp;\u0026quot;detail\u0026#x2F;common.hpp\u0026quot; namespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace\u0026nbsp;policy \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct exception_ptr_rethrow; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct exception_ptr_rethrow\u0026lt;T,\u0026nbsp;EC,\u0026nbsp;void\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} }  \n\nStruct outcome_v2_xxx::policy::exception_ptr_rethrow \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;EC,\u0026nbsp;class\u0026nbsp;E\u0026gt; struct\u0026nbsp;exception_ptr_rethrow;  Policy interpreting EC or E as a type for which trait::has_exception_ptr_v\u0026lt;EC|E\u0026gt; is true.\nAny wide attempt to access the successful state where there is none causes: std::rethrow_exception(policy::exception_ptr(.error()|.exception())) appropriately.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/void/",
	"title": "void",
	"tags": ["terminate"],
	"description": "",
	"content": "What about result\u0026lt;udt, void\u0026gt;? This is absolutely legal, it means that no error state is returned when there was an error. This can help with clarifying in code the use of std::optional\u0026lt;udt\u0026gt; as Optional more logically means value-or-nothing, not necessarily value-or-error.\nIn contrast, result\u0026lt;udt, void\u0026gt; unambiguously does mean success-or-failure, just with an unspecified cause of failure.\nOutcome\u0026rsquo;s default action for EC = void is to call std::terminate:\nstruct udt { int a{0}; explicit udt(int _a) : a(_a) { } udt() = default; int operator*() const { return a; } }; result\u0026lt;udt, void\u0026gt; res(in_place_type\u0026lt;void\u0026gt;); // What happens here? What exception type is thrown?  try { std::cout \u0026lt;\u0026lt; *res.value() \u0026lt;\u0026lt; std::endl; } catch(const std::exception \u0026amp;e) { std::cerr \u0026lt;\u0026lt; \u0026#34;Exception thrown was \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } View this code on Github Running this yields:\nned@lyta:~/outcome/build_posix$ bin/outcome-snippets_void_terminate terminate called without an active exception Aborted (core dumped) ned@lyta:~/outcome/build_posix$  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/conclusion/",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "This worked example was in fact excessively complex: a quicker route to achieving the same thing would be to add explicit converting constructors to app::error_code for each of the third party library E types. One then could have saved oneself with having to bother injecting custom converters into the OUTCOME_V2_NAMESPACE::convert namespace.\nHowever there are occasions when you don\u0026rsquo;t have control over the implementation of the destination E type e.g. in callbacks. Outcome\u0026rsquo;s ValueOrError infrastructure lets you inject custom interop code for any pair of incommensurate third party E types, without needing to modify either\u0026rsquo;s source code. This is without doubt a \u0026ldquo;power users\u0026rdquo; feature, but one which will prove useful as T|E based C++ code proliferates.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/constructors/metaprogrammg3/",
	"title": "Alternatives",
	"tags": [],
	"description": "",
	"content": "No doubt many will dislike the two-stage invocation pattern i.e.\nconstruct\u0026lt;file_handle\u0026gt;{\u0026#34;hello\u0026#34;}(); So let us examine the most obvious alternative: a templated free function construct\u0026lt;T\u0026gt;.\nDue to the inability to partially specialise templated functions in C++, you need to use tagged overloading e.g.\ntemplate\u0026lt;class... Args\u0026gt; inline outcome::result\u0026lt;file_handle\u0026gt; construct(std::in_place_type_t\u0026lt;file_handle\u0026gt;, Args\u0026amp;\u0026amp; ... args) { return file_handle::file(std::forward\u0026lt;Args\u0026gt;(args)...); } ... // Now you must always write this: construct(std::in_place_type\u0026lt;file_handle\u0026gt;, \u0026#34;hello\u0026#34;); Tagged overloading is fine for smaller projects, but for larger code bases:\n It takes longer to type construct(std::in_place_type\u0026lt;file_handle\u0026gt;, \u0026quot;hello\u0026quot;), and is possibly less intuitive to write, than it does construct\u0026lt;file_handle\u0026gt;{\u0026quot;hello\u0026quot;}(). Compiler error messages are enormously clearer if you encode the permitted overloads for construction into the construct\u0026lt;file_handle\u0026gt; type rather than letting a variadic free function fail to resolve an appropriate overload. Resolving variadic free function overloads is not constant time for the compiler, whereas resolving the type specialisation for construct\u0026lt;file_handle\u0026gt; is constant time. It actually turns out to be quite useful when writing generic code to pass around object constructing factory objects all of which have no parameters for their call operator. It becomes, effectively, a lazy construction mechanism.  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/convert/",
	"title": "Interoperation",
	"tags": [],
	"description": "",
	"content": " Header file convert.hpp \nnamespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace convert \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;ValueOrNone\u0026nbsp;=\u0026nbsp;detail::ValueOrNone\u0026lt;U\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;U\u0026gt;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;ValueOrError\u0026nbsp;=\u0026nbsp;detail::ValueOrError\u0026lt;U\u0026gt;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct value_or_error; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} }  \n\nStruct outcome_v2_xxx::convert::value_or_error \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;T,\u0026nbsp;class\u0026nbsp;U\u0026gt; struct\u0026nbsp;value_or_error { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;const enable_result_inputs; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;const enable_outcome_inputs; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;X,\u0026nbsp;typename\u0026nbsp;= std::enable_if_t\u0026lt;std::is_same\u0026lt;U,std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value\u0026amp;\u0026amp;ValueOrError\u0026lt;U\u0026gt;\u0026amp;\u0026amp;(std::is_void\u0026lt;typename std::decay_t\u0026lt;X\u0026gt;::value_type\u0026gt;::value||outcome_v2_xxx::detail::is_explicitly_constructible\u0026lt;typename T::value_type,typename std::decay_t\u0026lt;X\u0026gt;::value_type\u0026gt;)\u0026amp;\u0026amp;(std::is_void\u0026lt;typename std::decay_t\u0026lt;X\u0026gt;::error_type\u0026gt;::value||outcome_v2_xxx::detail::is_explicitly_constructible\u0026lt;typename T::error_type,typename std::decay_t\u0026lt;X\u0026gt;::error_type\u0026gt;)\u0026gt;\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;constexpr\u0026nbsp;T operator()(X\u0026amp;\u0026amp;\u0026nbsp;v); };  Default converter for types matching the ValueOrError concept.\nYou can partially or fully specialise this converter for your own user defined types by injecting specialisations into the convert namespace.\nVariable outcome_v2_xxx::convert::value_or_error::enable_result_inputs \nstatic\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;const\u0026nbsp;enable_result_inputs;  False to indicate that this converter wants result/outcome to reject all other result\nVariable outcome_v2_xxx::convert::value_or_error::enable_outcome_inputs \nstatic\u0026nbsp;constexpr\u0026nbsp;bool\u0026nbsp;const\u0026nbsp;enable_outcome_inputs;  False to indicate that this converter wants outcome to reject all other outcome\nFunction outcome_v2_xxx::convert::value_or_error::operator() \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;X,\u0026nbsp;typename\u0026nbsp;= std::enable_if_t\u0026lt;std::is_same\u0026lt;U,std::decay_t\u0026lt;X\u0026gt;\u0026gt;::value\u0026amp;\u0026amp;ValueOrError\u0026lt;U\u0026gt;\u0026amp;\u0026amp;(std::is_void\u0026lt;typename std::decay_t\u0026lt;X\u0026gt;::value_type\u0026gt;::value||outcome_v2_xxx::detail::is_explicitly_constructible\u0026lt;typename T::value_type,typename std::decay_t\u0026lt;X\u0026gt;::value_type\u0026gt;)\u0026amp;\u0026amp;(std::is_void\u0026lt;typename std::decay_t\u0026lt;X\u0026gt;::error_type\u0026gt;::value||outcome_v2_xxx::detail::is_explicitly_constructible\u0026lt;typename T::error_type,typename std::decay_t\u0026lt;X\u0026gt;::error_type\u0026gt;)\u0026gt;\u0026gt; constexpr\u0026nbsp;T\u0026nbsp;operator()(X\u0026amp;\u0026amp;\u0026nbsp;v);  Default converter for types matching the ValueOrError concept.\nRequires: std::decay_t\u0026lt;X\u0026gt; to be the same type as U; ValueOrError\u0026lt;U\u0026gt; to be true, U‚Äôs value_type be constructible into T‚Äôs value_type and U‚Äôs error_type be constructible into T‚Äôs error_type.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/policies/",
	"title": "Policies",
	"tags": ["policies"],
	"description": "Defining your own NoValuePolicy policies, plus an overview of the precanned policies which come in the Outcome source code.",
	"content": "Earlier in the section on Default actions, we covered all the different actions which Outcome can take upon no-value observation, and we noted that this facility is fully programmable.\nresult\u0026lt;T, EC\u0026gt; is actually result\u0026lt;T, EC, NoValuePolicy\u0026gt;. outcome\u0026lt;T, EC, EP\u0026gt; is in fact outcome\u0026lt;T, EC, EP, NoValuePolicy\u0026gt;. The NoValuePolicy template type is defaulted to a template alias as follows:\nnamespace policy { template \u0026lt;class T, class EC, class E\u0026gt; using default_policy = std::conditional_t\u0026lt; std::is_void\u0026lt;EC\u0026gt;::value \u0026amp;\u0026amp; std::is_void\u0026lt;E\u0026gt;::value, terminate, std::conditional_t\u0026lt; trait::has_error_code_v\u0026lt;EC\u0026gt;, error_code_throw_as_system_error\u0026lt;T, EC, E\u0026gt;, std::conditional_t\u0026lt; trait::has_exception_ptr_v\u0026lt;EC\u0026gt; || trait::has_exception_ptr_v\u0026lt;E\u0026gt;, exception_ptr_rethrow\u0026lt;T, EC, E\u0026gt;, all_narrow \u0026gt;\u0026gt;\u0026gt;; }  For unchecked\u0026lt;T, EC\u0026gt;, NoValuePolicy is hard coded to  policy::all_narrow . For checked\u0026lt;T, EC\u0026gt;, NoValuePolicy is hard coded to  policy::throw_bad_result_access\u0026lt;EC\u0026gt; .   These exactly match the Default Actions described earlier.\nThis section describes what a NoValuePolicy looks like, how to write your own, and each of the prewritten policies supplied with Outcome.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/terminate/",
	"title": "Termimate",
	"tags": [],
	"description": "",
	"content": " Header file terminate.hpp \n#include\u0026nbsp;\u0026quot;detail\u0026#x2F;common.hpp\u0026quot; namespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace\u0026nbsp;policy \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct terminate; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} }  \n\nStruct outcome_v2_xxx::policy::terminate \nstruct\u0026nbsp;terminate { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; };  Policy implementing any wide attempt to access the successful state as calling std::terminate\nCan be used in both result and outcome.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::terminate::wide_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, calls std::terminate().\nFunction outcome_v2_xxx::policy::terminate::wide_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, calls std::terminate().\nFunction outcome_v2_xxx::policy::terminate::wide_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the exception() functions\nEffects: If outcome does not have an exception, calls std::terminate().\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/default-actions/unchecked/",
	"title": "unchecked&lt;T, E&gt; and checked&lt;T, E&gt;",
	"tags": ["checked", "unchecked", "bad_result_access", "expected", "assume_value", "assume_error"],
	"description": "",
	"content": "We have now covered all of the default actions in Outcome whereby result\u0026lt;T, EC\u0026gt; and outcome\u0026lt;T, EC, EP\u0026gt; implement various default actions upon no-value observation according to traits defined upon the EC and EP chosen.\nIf you don\u0026rsquo;t want all this clever automatic detection of traits, and just want a plain, always-undefined-behaviour-on-no-value-observation success-or-failure type, we provide a simplified template alias to result\u0026lt;T, E\u0026gt; called  unchecked\u0026lt;T, E\u0026gt; . It literally does no run time checking whatsoever, no-value observation is always undefined behaviour.\nIf instead you would prefer a plain, always-throwing-logic-error-on-no-value-observation type, we also provide another simplified template alias to result\u0026lt;T, E\u0026gt; called  checked\u0026lt;T, E\u0026gt; . Similar to .value() in the WG21 Expected proposal or Optional, no-value observation throws these logic error type exceptions:\n No-value .value() observation throws  bad_result_access_with\u0026lt;E\u0026gt; . No-error .error() observation throws  bad_result_access .  If you need run time unchecked observers, .assume_value() and .assume_error() are always unchecked at run time.\nFinally, if you would like to implement your own default actions, you will find the tutorial section on Policies useful.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/bad_access/",
	"title": "Exceptions",
	"tags": [],
	"description": "",
	"content": " Header file bad_access.hpp \nnamespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;class bad_result_access; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;S\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;class bad_result_access_with; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;class bad_outcome_access; }  \nClass outcome_v2_xxx::bad_result_access \nclass\u0026nbsp;bad_result_access :\u0026nbsp;public\u0026nbsp;std::logic_error { public: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;explicit\u0026nbsp;bad_result_access(char\u0026nbsp;const*\u0026nbsp;what); };  Thrown when you try to access state in a result\u0026lt;R, S\u0026gt; which isn‚Äôt present.\nClass outcome_v2_xxx::bad_result_access_with \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;S\u0026gt; class\u0026nbsp;bad_result_access_with :\u0026nbsp;public\u0026nbsp;bad_result_access { public: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;explicit\u0026nbsp;bad_result_access_with(S\u0026nbsp;v); \u0026#x2F;\u0026#x2F;=== result_error ===\u0026#x2F;\u0026#x2F; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;S\u0026nbsp;const\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;S\u0026amp; error()\u0026nbsp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;S\u0026nbsp;const\u0026amp;\u0026amp; error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;S\u0026amp;\u0026amp; error()\u0026nbsp;\u0026amp;\u0026amp;; };  Thrown when you try to access a value in a result\u0026lt;R, S\u0026gt; which isn‚Äôt present.\nFunction outcome_v2_xxx::bad_result_access_with::error \n(1)\u0026nbsp;S\u0026nbsp;const\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;; (2)\u0026nbsp;S\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;; (3)\u0026nbsp;S\u0026nbsp;const\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;const\u0026nbsp;\u0026amp;\u0026amp;; (4)\u0026nbsp;S\u0026amp;\u0026amp;\u0026nbsp;error()\u0026nbsp;\u0026amp;\u0026amp;;  Observes the error\nClass outcome_v2_xxx::bad_outcome_access \nclass\u0026nbsp;bad_outcome_access :\u0026nbsp;public\u0026nbsp;std::logic_error { public: \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;explicit\u0026nbsp;bad_outcome_access(char\u0026nbsp;const*\u0026nbsp;what); };  Thrown when you try to access state in a outcome\u0026lt;T, EC, E\u0026gt; which isn‚Äôt present.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/throw_bad_result_access/",
	"title": "Throw bad_result_access",
	"tags": [],
	"description": "",
	"content": " Header file throw_bad_result_access.hpp \n#include\u0026nbsp;\u0026quot;detail\u0026#x2F;common.hpp\u0026quot; namespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;namespace\u0026nbsp;policy \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;{ \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;EC\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;struct throw_bad_result_access; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;} }  \n\nStruct outcome_v2_xxx::policy::throw_bad_result_access \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;EC\u0026gt; struct\u0026nbsp;throw_bad_result_access { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;static\u0026nbsp;constexpr\u0026nbsp;void narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept; };  Policy which throws bad_result_access_with\u0026lt;EC\u0026gt; or bad_result_access during wide checks.\nCan be used in result only.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_value() functions.\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_error() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::narrow_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;narrow_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self)\u0026nbsp;noexcept;  Performs a narrow check of state, used in the assume_exception() functions\nEffects: None.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::wide_value_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_value_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the value() functions.\nEffects: If result does not have a value, it throws bad_result_access_with\u0026lt;EC\u0026gt;.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::wide_error_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_error_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the error() functions\nEffects: If result does not have an error, it throws bad_result_access.\nFunction outcome_v2_xxx::policy::throw_bad_result_access::wide_exception_check \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;Impl\u0026gt; static\u0026nbsp;constexpr\u0026nbsp;void\u0026nbsp;wide_exception_check(Impl\u0026amp;\u0026amp;\u0026nbsp;self);  Performs a wide check of state, used in the exception() functions\nEffects: If result does not have an exception, it throws bad_outcome_access.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/c-api/",
	"title": "Using result&lt;T&gt; from C code",
	"tags": [],
	"description": "Interacting with result&lt;T, EC&gt; returning C++ functions from C code.",
	"content": "A long standing problem for C code (or more usually nowadays, the many other programming languages which can speak the C ABI but not the C++ ABI) is how to interpret C++ exception throws. The answer is of course that they cannot, thus requiring one to write C shim code on the C++ side of things of the form:\n// The API we wish to expose to C const char *get_value(double v); // The C shim function for the C++ get_value() function. extern \u0026#34;C\u0026#34; int c_get_value(const char **ret, double v) { try { *ret = get_value(v); return 0; // success  } catch(const std::range_error \u0026amp;) { return ERANGE; } // More catch clauses may go in here ...  catch(...) { return EAGAIN; } } This is sufficiently painful that most reach for a bindings generator tool like SWIG to automate this sort of tedious boilerplate generation. And this is fine for larger projects, but for smaller projects the cost of setting up and configuring SWIG is also non-trivial.\nWhat would be really great is if result\u0026lt;T\u0026gt; returning noexcept C++ functions could be used straight from C. And indeed Outcome provides just that facility which this section covers next.\n"
},
{
	"uri": "https://ned14.github.io/outcome/changelog/",
	"title": "Changelog",
	"tags": [],
	"description": "",
	"content": " v2.1 in progress [project]  #140\n Fixed a nasty corner case bug where value type\u0026rsquo;s without a copy constructor but with a move constructor would indicate via traits that copy construction was available. Thanks to Microsoft\u0026rsquo;s compiler team for reporting this issue.  Added experimental status_result and status_outcome based on experimental status_code.\n Boost edition is now 100% Boost, so defaults for result and outcome are boost::system::error_code::errc_t and boost::exception_ptr. Moreover, the test suite in the Boost edition now exclusively tests the Boost edition. One can, of course, freely use the standalone edition with Boost, and the Boost edition with std types.\n Renamed ADL discovered customisation point throw_as_system_error_with_payload() to outcome_throw_as_system_error_with_payload().\n #135\n Added much clearer compile failure when user tries result\u0026lt;T, T\u0026gt; or outcome where two or more types are identical. Thanks to Andrzej Krzemie≈Ñski for suggesting a technique which combines SFINAE correctness with the remaining ability for result\u0026lt;T, T\u0026gt; etc to be a valid type, but not constructible.  #67\n Fixed one of the oldest long open bugs in Outcome, that the noexcept unit tests failed on OS X for an unknown reason.  #115\n Outcome did not construct correctly from failure_type.  Inexplicably outcome\u0026rsquo;s error + exception constructor had been removed. Nobody noticed during the Boost peer review, which is worrying seeing as that constructor is needed for one of the main advertised features to Boost!\n #107 and #116\n operator== and operator!= now become disabled if the value, error and exception types do not implement the same operator. Relatedly, both comparison operators simply didn\u0026rsquo;t work right. Fixed.  #109\n swap() now has correct noexcept calculation and now correctly orders the swaps to be whichever is the throwing swap first.  Added reference dump of v2.1 ABI so we can check if ABI breakage detection works in the next set of changes, plus Travis job to check ABI and API compatibility per commit.\n #124\n OUTCOME_TRY is now overloaded and selects void or auto edition according to input parameter count.  #120\n Fix generation of double underscored temporary variables in OUTCOME_UNIQUE_NAME, which is UB.  #110\n Separated result from its hard coded dependency on the \u0026lt;system_error\u0026gt; header. Renamed result and outcome to basic_result and basic_outcome. Renamed result.hpp into basic_result.hpp. Moved \u0026lt;system_error\u0026gt; and \u0026lt;exception\u0026gt; dependent code into new std_result.hpp and std_outcome.hpp header files. Added boost_result.hpp and boost_outcome.hpp which use Boost.System and Boost.Exception (these are result.hpp and outcome.hpp in the Boost edition).   v2.0 18th Jan 2018 [release]  Boost peer review edition. This is what was reviewed. Changelog from v1 can be found in the release notes for this release.  "
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/interop/",
	"title": "Interoperation",
	"tags": [],
	"description": "Interoperating with std::expected&lt;T, E&gt; and other ValueOrError concept matching types.",
	"content": "This is the final section of the tutorial, and it is unavoidably quite lengthy.\nOne thing which Outcome solves \u0026ndash; which alternatives do not \u0026ndash; is how to non-intrusively tie together multiple third party libraries, each using Outcome \u0026ndash; or some other T|E implementatation like std::expected\u0026lt;T, E\u0026gt; \u0026ndash; with custom incommensurate E types, or indeed arbitrary return types which are \u0026ldquo;split\u0026rdquo; T|E return types. Solving this well is the coup de gr√¢ce of Outcome against alternative approaches to this problem domain, including std::expected\u0026lt;T, E\u0026gt;. It is the major reason why you should consider using Outcome over alternatives, including Expected.\nFirstly we shall explore some of the problems faced by the software developer when T|E return type based code proliferates at scale, where dozens of libraries may be using completely incompatible T|E return types.\nSecondly we shall introduce the ValueOrError concept support in Outcome which implements a subset of the proposed WG21 ValueOrError concept framework.\nFinally, we shall then step through a worked example which mocks up a realistic situation that the software developer may find themselves in: tying together disparate third party libraries, whose source code cannot be modified, into an application-wide, mixed-mode T|E and exception throwing universal error handling system which is capable of accurately representing the original failure, but also propagating it in a way that the application can deal with universally.\n"
},
{
	"uri": "https://ned14.github.io/outcome/reference/iostream_support/",
	"title": "iostream support",
	"tags": [],
	"description": "",
	"content": " Header file iostream_support.hpp \nnamespace\u0026nbsp;outcome_v2_xxx { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp;\u0026nbsp;s, result\u0026lt;R, S, P\u0026gt;\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;\u0026nbsp;s, result\u0026lt;R, S, P\u0026gt;\u0026nbsp;const\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::string print(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::string print(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;P\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::string print(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;P\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::string print(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp;\u0026nbsp;s, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp;\u0026nbsp;s, outcome\u0026lt;R, S, P, N\u0026gt;\u0026nbsp;const\u0026amp;\u0026nbsp;v); \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;template\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;std::string print(outcome\u0026lt;R, S, P, N\u0026gt;\u0026nbsp;const\u0026amp;\u0026nbsp;v); }  \nFunction outcome_v2_xxx::operator\u0026gt;\u0026gt; \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; std::istream\u0026amp;\u0026nbsp;operator\u0026gt;\u0026gt;(std::istream\u0026amp;\u0026nbsp;s, result\u0026lt;R, S, P\u0026gt;\u0026amp;\u0026nbsp;v);  Deserialise a result. Format is status_unsigned [value][error]. Spare storage is preserved.\nRequires: That R and S implement operator\u0026gt;\u0026gt;.\nFunction outcome_v2_xxx::operator\u0026lt;\u0026lt; \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; std::ostream\u0026amp;\u0026nbsp;operator\u0026lt;\u0026lt;(std::ostream\u0026amp;\u0026nbsp;s, result\u0026lt;R, S, P\u0026gt;\u0026nbsp;const\u0026amp;\u0026nbsp;v);  Serialise a result. Format is status_unsigned [value][error]. Spare storage is preserved.\nRequires: That R and S implement operator\u0026lt;\u0026lt;.\nIf you are printing to a human readable destination, use print() instead.\nFunction outcome_v2_xxx::print \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; std::string\u0026nbsp;print(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp;\u0026nbsp;v);  Debug print a result into a form suitable for human reading. Format is value|error. If the error type is error_code, appends \u0026quot; (ec.message())\u0026quot; afterwards.\nFunction outcome_v2_xxx::print \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P\u0026gt; std::string\u0026nbsp;print(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp;\u0026nbsp;v);  Debug print a result into a form suitable for human reading. Format is (+void)|error. If the error type is error_code, appends \u0026quot; (ec.message())\u0026quot; afterwards.\nFunction outcome_v2_xxx::print \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;P\u0026gt; std::string\u0026nbsp;print(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp;\u0026nbsp;v);  Debug print a result into a form suitable for human reading. Format is value|(-void).\nFunction outcome_v2_xxx::print \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;P\u0026gt; std::string\u0026nbsp;print(\u0026#x27;hidden\u0026#x27;\u0026nbsp;const\u0026amp;\u0026nbsp;v);  Debug print a result into a form suitable for human reading. Format is (+void)|(-void).\nFunction outcome_v2_xxx::operator\u0026gt;\u0026gt; \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; std::istream\u0026amp;\u0026nbsp;operator\u0026gt;\u0026gt;(std::istream\u0026amp;\u0026nbsp;s, outcome\u0026lt;R, S, P, N\u0026gt;\u0026amp;\u0026nbsp;v);  Deserialise an outcome. Format is status_unsigned [value][error][exception]. Spare storage is preserved.\nRequires: That R, S and P implement operator\u0026gt;\u0026gt;.\nFunction outcome_v2_xxx::operator\u0026lt;\u0026lt; \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; std::ostream\u0026amp;\u0026nbsp;operator\u0026lt;\u0026lt;(std::ostream\u0026amp;\u0026nbsp;s, outcome\u0026lt;R, S, P, N\u0026gt;\u0026nbsp;const\u0026amp;\u0026nbsp;v);  Serialise an outcome. Format is status_unsigned [value][error][exception]. Spare storage is preserved.\nRequires: That R, S and P implement operator\u0026lt;\u0026lt;.\nIf you are printing to a human readable destination, use print() instead.\nFunction outcome_v2_xxx::print \ntemplate\u0026nbsp;\u0026lt;class\u0026nbsp;R,\u0026nbsp;class\u0026nbsp;S,\u0026nbsp;class\u0026nbsp;P,\u0026nbsp;class\u0026nbsp;N\u0026gt; std::string\u0026nbsp;print(outcome\u0026lt;R, S, P, N\u0026gt;\u0026nbsp;const\u0026amp;\u0026nbsp;v);  Debug print an outcome into a form suitable for human reading. Format is one of:\n value|error|exception\n { error, exception }\n  If the error type is error_code, appends \u0026quot; (ec.message())\u0026quot; after the error. Exception type is printed as one of:\n std::system_error code code(): what()\n std::exception: what()\n unknown exception\n  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/result_c/",
	"title": "C API",
	"tags": [],
	"description": "",
	"content": " Header file result_c \nstruct cxx_error_code; #define CXX_DECLARE_RESULT(R,RD,S,SD) #define CXX_DECLARE_RESULT_EC(R,RD) #define CXX_RESULT(R,S) #define CXX_RESULT_EC(R) #define CXX_RESULT_HAS_VALUE(r) #define CXX_RESULT_HAS_ERROR(r) #define CXX_RESULT_ERROR_IS_ERRNO(r) #define CXX_RESULT_ERROR(r) #define CXX_RESULT_SET_ERRNO(r)  Struct cxx_error_code \nstruct\u0026nbsp;cxx_error_code { \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;int\u0026nbsp;code; \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;void*\u0026nbsp;category; };  A C struct representation of std::error_code.\nMacro CXX_DECLARE_RESULT \n#define\u0026nbsp;CXX_DECLARE_RESULT(R,RD,S,SD)\u0026nbsp;struct result_##R##_##S { RD value; unsigned flags; SD error; }  Declares a C struct representation of result\u0026lt;R, S\u0026gt;.\nMacro CXX_DECLARE_RESULT_EC \n#define\u0026nbsp;CXX_DECLARE_RESULT_EC(R,RD)\u0026nbsp;CXX_DECLARE_RESULT(R, RD, errorcode, struct cxx_error_code)  Declares a C struct representation of result\u0026lt;R, std::error_code\u0026gt;.\nMacro CXX_RESULT \n#define\u0026nbsp;CXX_RESULT(R,S)\u0026nbsp;struct result_##R##_##S  A reference to a previously declared struct by CXX_DECLARE_RESULT(R, RD, S, SD)\nMacro CXX_RESULT_EC \n#define\u0026nbsp;CXX_RESULT_EC(R)\u0026nbsp;struct result_##R##_errorcode  A reference to a previously declared struct by CXX_DECLARE_RESULT_EC(R, RD)\nMacro CXX_RESULT_HAS_VALUE \n#define\u0026nbsp;CXX_RESULT_HAS_VALUE(r)\u0026nbsp;(((r).flags \u0026amp; 1U) == 1U)  True if a result struct has a valid value\nMacro CXX_RESULT_HAS_ERROR \n#define\u0026nbsp;CXX_RESULT_HAS_ERROR(r)\u0026nbsp;(((r).flags \u0026amp; 2U) == 2U)  True if a result struct has a valid error\nMacro CXX_RESULT_ERROR_IS_ERRNO \n#define\u0026nbsp;CXX_RESULT_ERROR_IS_ERRNO(r)\u0026nbsp;(((r).flags \u0026amp; (1U \u0026lt;\u0026lt; 4U)) == (1U \u0026lt;\u0026lt; 4U))  True if a result struct‚Äôs error or code is an errno domain code suitable for setting errno with.\nMacro CXX_RESULT_ERROR \n#define\u0026nbsp;CXX_RESULT_ERROR(r)\u0026nbsp;_Generic((r).error, struct cxx_error_code : ((struct cxx_error_code *) \u0026amp;(r).error)-\u0026gt;code, default : (r).error)  C11 generic selecting a result struct‚Äôs error or code integer member.\nMacro CXX_RESULT_SET_ERRNO \n#define\u0026nbsp;CXX_RESULT_SET_ERRNO(r)\u0026nbsp;(errno = CXX_RESULT_HAS_ERROR(r) ? (CXX_RESULT_ERROR_IS_ERRNO(r) ? CXX_RESULT_ERROR(r) : EAGAIN) : 0)  Convenience macro setting errno to a result struct‚Äôs errno compatible error if present, or EAGAIN if errored but incompatible.\n"
},
{
	"uri": "https://ned14.github.io/outcome/history/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": " Outcome has had an interesting history, and it is worth summarising it here to show how a Boost library comes to life. The following recollections are by Niall Douglas, and may be faulty due to his aging memory.\ngantt dateFormat YYYY-MM title History of the Outcome library Outcome v1: done, des1, 2014-06,2017-05 Boost peer review of v1: done, des2, after des1, 30d Outcome v2 development: done, des3, after des2, 2018-01 Boost peer review of v2: done, des4, after des3, 30d Outcome v2.1 development: active, des5, 2018-03, 2018-12 section Events Separated from AFIO v1: crit, done, 2014-06,2d Boost.Expected added: crit, done, 2014-10,2d Boost.Expected replaced with feature complete basic_monad: crit, done, 2015-08,2d Non-allocating future-promise implementation dropped: crit, done, 2016-05,2d C++ 11 support dropped: crit, done, 2016-06,2d Implemented LEWG expected\u0026lt;T, E\u0026gt; using basic_monad: crit, done, 2017-02,2d Outcome v1 replaced with prototype v2 in git repo: crit, done, 2017-07,2d Boost.Outcome generated by script from Outcome repo: crit, done, 2017-10,2d New tutorial finally complete: crit, done, 2017-12,2d Planned release of v2.1 into Boost 1.69: crit, active, 2018-12,2d  The genesis of Outcome v1 The git repo began life as a \u0026ldquo;Boost.Spinlock\u0026rdquo; in June 2014 hived out of Boost.AFIO v1 where it had existed for some time as an internal library. In October 2014 I added in the original prototype Boost.Expected reference library as a git submodule, and began developing a non-allocating future\u0026lt;T\u0026gt;/promise\u0026lt;T\u0026gt; as an extension of expected\u0026lt;T, std::exception_ptr\u0026gt; as a faster, monadic future-promise was something which AFIO v1 sorely needed.\nThe original prototype Boost.Expected library was a large and very complex beastie. I was fortunate to be employed on a contract in late 2014 early 2015 where I saw it deployed at scale into an existing large C++ codebase. Expected was really great and powerful, but it absolutely murdered compile times in a large C++ codebase, and made LTO effectively infeasible. I also found its implementation non-conducive to implementing future-promise with it, and so I resolved to implement a much more powerful policy driven monad factory which could stamp out everything from an option\u0026lt;T\u0026gt; right through to a future-promise pair, all using the exact same basic_monad\u0026lt;\u0026gt; and therefore all with a full monadic programming API, C++ 17 continuations/monadic bind and intelligently convertible into one another. Moreover, all this needed to have an absolute minimum impact on compile times and runtime overheads, neither of which were strengths of the original prototype Boost.Expected library.\nBy August 2015 \u0026ldquo;Boost.Monad\u0026rdquo; was delivering on all those requirements and then some, but it lacked maturity through use in other code. Summer 2015 saw the Boost peer review of AFIO v1 which was roundly rejected. After considering the ample review feedback, it was realised that AFIO v2 would be a very different design, one no longer using futures, memory allocation nor C++ exceptions. As AFIO v2 was started from scratch and using Outcome heavily from the very beginning (every AFIO v2 API returns a result\u0026lt;T\u0026gt;), Outcome began to gain bug fixes and shed features, with the non-allocating future-promise implementation being dropped in May 2016 and a large chunk of metaprogramming being replaced with cleaner variable templates in June. After CppCon 2016 in September, then began the long process of getting Outcome ready for Boost peer review in Q1 2017 which involved a repeated sequence of complete rewrites of the tutorial in response to multiple rounds of feedback from the C++ community, with at least four complete rewrites currently at the time of writing.\nIn parallel to all this development on Outcome, Expected went before the LEWG and entered the C++ standards track. As the WG21 meetings went by, Expected experienced a period of being stripped back and much of the complexity which had so murdered compile and link times in 2014-2015 fell away, thus the Expected proposed in P0323R1 ended up landing so close to Outcome that in January 2017 it was just a few hours work to implement Expected using the core basic_monad infrastructure in Outcome. That highly flexible policy based design which made monadic future-promise possible made it similarly easy to implement a highly conforming Expected, indeed in early 2017 Outcome\u0026rsquo;s Expected was much closer to P0323R1 than any other implementation including the LEWG reference implementation. And unlike the LEWG reference implementation, Outcome has had eighteen months of that finely tuned patina you only get when a library is in use by other code bases.\nIn February 2017 it became realised that the userbase really wanted a high quality expected\u0026lt;T, E\u0026gt; implementation rather than anything similar but not the same which Outcome had invented. The only just implemented Expected implementation based on basic_monad therefore took primacy. The final rewrite of the documentation before peer review submission was one which made it look like Outcome was primarily an expected\u0026lt;T, E\u0026gt; implementation with a few useful extensions like outcome\u0026lt;T\u0026gt; and result\u0026lt;T\u0026gt;. I was sad to so pivot, but it was obvious that Outcome would see far wider popularity and usage as primarily an Expected implementation.\nAlmost three years after its beginning, Outcome v1 finally went before Boost peer review in May 2017 which turned into one of the longest and most detailed peer reviews Boost has done in recent years, with over 800 pieces of review feedback submitted. It was by consensus rejected, with substantial feedback on what to do instead.\nOutcome v2 During the very lengthy peer review, roughly three groups of opinion emerged as to what a value|error transporting class ought to look like:\n 1. Lightweight A simple-as-possible T and/or E transport without any implementation complexity. 2. Medium A variant stored T or E1 ... En where T is the expected value and E1 ... are the potential unexpected values. This implemention really ought to be implemented using C++ 17's std::variant except with stronger never-empty guarantees.  3. Heavy A full fat Either monad participating fully in a wider monadic programming framework for C++.  Peter Dimov was very quickly able to implement an expected\u0026lt;T, E1, ...\u0026gt; using his variant2 library, and thus there seemed little point in replicating his work in an Outcome v2. The lightweight choice seemed to be the best path forwards, so in June 2017 the bare minimum result\u0026lt;T, E\u0026gt; and outcome\u0026lt;T, EC, P\u0026gt; as presented in this library was built, using the same constructor design as std::variant\u0026lt;...\u0026gt;. Significant backwards compatibility with v1 Outcome code was retained, as the review had felt the basic proposed design fine.\nA period of maturation then followed by porting a large existing codebase using Outcome v1 to v2, and writing a significant amount of new code using v2 to test it for unanticipated surprises and bugs. Quite a few corner cases were found and fixed. At the end of September 2017, Outcome v2 was deemed to be \u0026ldquo;mature\u0026rdquo;, and a script generated \u0026ldquo;Boost edition\u0026rdquo; made available.\nAll that remained before it was ready for a second Boost peer review was the documentation. This took four months to write (same time as to write the library itself!), and in January 2018 Outcome had its second Boost peer review, which it passed!\nPost-review Outcome passing its review in January had much more consequence than I could have ever expected. Unbeknownst to me, the WG21 leadership had interpreted the success of Outcome, and especially its divergences from WG21 Expected, as a sign that the C++ exception handling mechanism was no longer fit for purpose. It was thus resolved to remedy the standard exception handling mechanism into something much more efficient, thus rendering Outcome obsolete in future C++ standards.\nJust before the review, I had mooted a number of semantic and compile time performance improvements to \u0026lt;system_error\u0026gt; with the proposal that we mildly break Boost.System with improvements and see how badly real world code broke in response. This was not widely accepted. I therefore wrote an improved \u0026lt;system_error2\u0026gt; which fixed all the problems listed at P0824 (Summary of SG14 discussion on \u0026lt;system_error\u0026gt;) and fixed up Outcome so one could use it without any system error implementation, or with the STL one or with the proposed improved one.\nTo be continued after Jacksonville \u0026hellip;\n"
},
{
	"uri": "https://ned14.github.io/outcome/tutorial/error_code/",
	"title": "Custom error codes",
	"tags": [],
	"description": "Illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes.",
	"content": "This section illustrates how you can hook into the std::error_code system from the Standard Library in order to work with your own set of error codes. As is usually the case in C++, doing this is straightforward but requires typing boilerplate to tell the C++ STL about your custom error type. This is not part of Outcome library, but we still provide this short guide here, because how to do this is not well documented [1].\nSuppose you want to report all reasons for failure in converting a std::string to a non-negative int. The list is:\n EmptyString \u0026ndash; the input string is empty, IllegalChar \u0026ndash; input contains characters that are not digits, TooLong \u0026ndash; input represents a number, but this number would not fit into a variable of type int.  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt; // for string printing#include \u0026lt;system_error\u0026gt; // bring in std::error_code et al // This is the custom error code enum enum class ConversionErrc { EmptyString = 1, // 0 is never an error  IllegalChar = 2, TooLong = 3, }; namespace std { // Tell the C++ 11 STL metaprogramming that enum ConversionErrc  // is registered with the standard error code system  template \u0026lt;\u0026gt; struct is_error_code_enum\u0026lt;ConversionErrc\u0026gt; : std::true_type { }; } namespace detail { // Define a custom error code category derived from std::error_category  class ConversionErrc_category : public std::error_category { public: // Return a short descriptive name for the category  virtual const char *name() const noexcept override final { return \u0026#34;ConversionError\u0026#34;; } // Return what each enum means in text  virtual std::string message(int c) const override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::EmptyString: return \u0026#34;converting empty string\u0026#34;; case ConversionErrc::IllegalChar: return \u0026#34;got non-digit chatr when converting to a number\u0026#34;; case ConversionErrc::TooLong: return \u0026#34;the number would not fit into memory\u0026#34;; default: return \u0026#34;unknown\u0026#34;; } } // OPTIONAL: Allow generic error conditions to be compared to me  virtual std::error_condition default_error_condition(int c) const noexcept override final { switch (static_cast\u0026lt;ConversionErrc\u0026gt;(c)) { case ConversionErrc::EmptyString: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::IllegalChar: return make_error_condition(std::errc::invalid_argument); case ConversionErrc::TooLong: return make_error_condition(std::errc::result_out_of_range); default: // I have no mapping for this code  return std::error_condition(c, *this); } } }; } // Define the linkage for this function to be used by external code. // This would be the usual __declspec(dllexport) or __declspec(dllimport) // if we were in a Windows DLL etc. But for this example use a global // instance but with inline linkage so multiple definitions do not collide. #define THIS_MODULE_API_DECL extern inline  // Declare a global function returning a static instance of the custom category THIS_MODULE_API_DECL const detail::ConversionErrc_category \u0026amp;ConversionErrc_category() { static detail::ConversionErrc_category c; return c; } // Overload the global make_error_code() free function with our // custom enum. It will be found via ADL by the compiler if needed. inline std::error_code make_error_code(ConversionErrc e) { return {static_cast\u0026lt;int\u0026gt;(e), ConversionErrc_category()}; } int main(void) { // Note that we can now supply ConversionErrc directly to error_code  std::error_code ec = ConversionErrc::IllegalChar; std::cout \u0026lt;\u0026lt; \u0026#34;ConversionErrc::IllegalChar is printed by std::error_code as \u0026#34; \u0026lt;\u0026lt; ec \u0026lt;\u0026lt; \u0026#34; with explanatory message \u0026#34; \u0026lt;\u0026lt; ec.message() \u0026lt;\u0026lt; std::endl; // We can compare ConversionErrc containing error codes to generic conditions  std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::invalid_argument = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::invalid_argument) \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;ec is equivalent to std::errc::result_out_of_range = \u0026#34; \u0026lt;\u0026lt; (ec == std::errc::result_out_of_range) \u0026lt;\u0026lt; std::endl; return 0; } View this code on Github This might look like a lot of extra boilerplate over simply using your custom error code enum directly, but look at the advantages:\n Any code which can speak std::error_code can now work with errors from your code, AND without being recompiled. std::system_error can now wrap your custom error codes seamlessly, allowing your custom error code to be converted into a C++ exception and back out again without losing information. std::error_code knows how to print itself, and will print your custom error code without extra work from you. As usually you\u0026rsquo;d need to define a print routine for any custom error code you\u0026rsquo;d write anyway, there is actually very little extra boilerplate here. If you implement the default_error_condition() override, you can allow code exclusively written to understand std::errc alone to examine your custom error code domain for equivalence to the standard error conditions, AND without being recompiled.  [1]: The only documentation I\u0026rsquo;m aware of is the quite old guide by Chris Kohlhoff, founder of ASIO and the Networking TS:\n http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-2.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-3.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-4.html http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-5.html  "
},
{
	"uri": "https://ned14.github.io/outcome/reference/policies/",
	"title": "Policies",
	"tags": [],
	"description": "",
	"content": "  All narrow (hard UB) error_code throw as system_error (Outcome) error_code throw as system_error (Result) exception_ptr rethrow (Outcome) exception_ptr rethrow (Result) Termimate Throw bad_result_access  "
},
{
	"uri": "https://ned14.github.io/outcome/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Outcome 2.0 library documentation\n"
},
{
	"uri": "https://ned14.github.io/outcome/credits/",
	"title": "Acknowledgements",
	"tags": [],
	"description": "Giving thanks to those who made Outcome happen",
	"content": " github contributors .ghContributors{ display:flex; flex-flow: wrap; align-content: flex-start } .ghContributors  div{ width: 50% ; display: inline-flex; margin-bottom: 5px; } .ghContributors  div label{ padding-left: 4px ; } .ghContributors  div span{ font-size: x-small; padding-left: 4px ; }   @ned14 890 commits   @akrzemi1 19 commits   @menuet 2 commits   @norbertwenzel 1 commits   @vinipsmaker 1 commits   @andoks 1 commits   @catskul 1 commits   @jenkins-nedprod 1 commits   This pretty, modern C++ documentation  Hugo - static website generator of this documentation. hugo-theme-docdock - the Hugo theme used by this documentation. Standardese - the API reference generator  Special thanks for Outcome v2 For a second time, Charley Bay stepped up as review manager. Given how much work it was for the v1 review, I can only say thank you.\nAndrzej Krzemienski went far beyond the call of duty in the development of Outcome v2. He wrote the front page, and the start of the tutorial. He thus set the tone, pacing, style and form of the tutorial which I merely continued for the rest of the tutorial. He also volunteered considerable amounts of his time as as primary peer reviewer for the v2 design and implementation, asking many very valuable \u0026ldquo;stupid questions\u0026rdquo; at least one of which caused a major rethink and refactor. If Outcome v2 passes its second peer review, it\u0026rsquo;s because of Andrzej. Thank you.\nJonathan M√ºller invested countless hours in his doxygen replacement tool Standardese which Outcome uses to generate the reference API docs, and a not insignificant number of those went on fixing issues for Outcome. Thank you.\nSpecial thanks for Outcome v1 To Paul Bristow who proposed the name \u0026ldquo;Outcome\u0026rdquo; for the library after a very extended period of name bikeshedding on boost-dev. I had been minded to call the library \u0026ldquo;Boost.Donkey\u0026rdquo; just to shut everyone up because the name bike shedding was getting ridiculous. But Outcome is a lot nicer, so thank you Paul.\nMy heartfelt thanks to Charley Bay for acting as review manager for Outcome in May 2017. It is becoming ever harder to find a Boost review manager, so thank you! My thanks also to the CppCast team Rob Irving and Jason Turner for so quickly getting me on to CppCast to discuss expected\u0026lt;T, E\u0026gt; during the Outcome peer review to help publicise the review.\nMore general thanks are due to those on boost-dev, Reddit and SG14 for extensive and often very detailed feedback on the library pretty much from its beginning. You are all too numerous to remember, but certainly Tongari and Andrzej Krzemienski come to mind as having engaged in particularly long discussion threads with tons of useful feedback which clarified my thinking. Andrzej also went through the documentation with a fine toothed comb before the review, finding many small errata and confusing wording.\nFinally, my thanks to Vicente for driving Expected from its beginnings to hopefully standardisation before 2020. It\u0026rsquo;s many years of work getting something standardised, even more years than getting a library into Boost which as you can see from the history above took about three years.\n"
},
{
	"uri": "https://ned14.github.io/outcome/tags/adl-bridging/",
	"title": "Adl Bridging",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/assume_error/",
	"title": "Assume_error",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/assume_value/",
	"title": "Assume_value",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/backtrace/",
	"title": "Backtrace",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/bad_result_access/",
	"title": "Bad_result_access",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/checked/",
	"title": "Checked",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/constructors/",
	"title": "Constructors",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/default-actions/",
	"title": "Default Actions",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/dual-api/",
	"title": "Dual Api",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/error/",
	"title": "Error",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/exception/",
	"title": "Exception",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/expected/",
	"title": "Expected",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/has_error_code/",
	"title": "Has_error_code",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": " Outcome 2.0 library Outcome is a set of tools for reporting and handling function failures in contexts where using C++ exception handling is unsuitable. Such contexts include:\n programs, or parts thereof, that are compiled with exceptions disabled;\n parts of program that have a lot of branches depending on types of failures, where if-statements are cleaner than try-catch blocks;\n requirement that failure path of execution should not cost more than the successful path of execution;\n situations, like in filesystem library, where the decision whether the failure should be handled remotely (use exceptions) or locally cannot be made inside the function and needs to be moved onto the caller, and in the latter case launching stack unwinding is not desireable for the aforementioned reasons;\n parts of the programs/frameworks that themselves implement exception handling and prefer to not use exceptions to propagate failure reports across thread, tasks, fibers;\n propagating exceptions trough layers that do not implement exception throw safety;\n external requirement (such as company-wide policy) that failure handling paths are explicitly indicated in the code.\n  Outcome addresses failure handling through returning a special type form functions, which is able to store either a succesfully computed value (or void) or the information about failure. Outcome also comes with a set of idioms for dealing with such types.\nSample usage One of the tools in the Outcome library is result\u0026lt;T\u0026gt;: it represents either a succesfully computed value of type T or an std::error_code representing the reason for failure. You use it in the function\u0026rsquo;s return type:\nauto read_data_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;string\u0026gt;; View this code on Github It is possible to inspect the state manualy:\nif (auto rslt = read_data_from_file(\u0026#34;config.cfg\u0026#34;)) use_string(rslt.value()); // returns string else throw LibError{rslt.error(), \u0026#34;config.cfg\u0026#34;}; // returns error_code View this code on Github Or, if this function is called in anoter function that also returns result\u0026lt;T\u0026gt; you can use a dedicated control statement:\nauto process(const string\u0026amp; content) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt;; auto get_int_from_file(string_view path) noexcept -\u0026gt; outcome::result\u0026lt;int\u0026gt; { OUTCOME_TRY(str, (read_data_from_file(path))); // if control gets here read_data_from_file() has succeeded  return process(str); // decltype(str) == string } View this code on Github OUTCOME_TRY is a control statement. If the returned result\u0026lt;T\u0026gt; contains an error information, the enclosing function is immediatelly returned with result\u0026lt;U\u0026gt; containing the same failure information; otherwise object of type T is move-constructed on the stack.\nThis is the v2 Outcome designed in response to feedback from a Boost peer review held in May 2017. This library has successfully passed the second Boost peer review, and is currently expected to become part of the Boost official release distribution before the 1.69 release.\n "
},
{
	"uri": "https://ned14.github.io/outcome/tags/hooks/",
	"title": "Hooks",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/make_error_code/",
	"title": "Make_error_code",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/namespace/",
	"title": "Namespace",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/nodiscard/",
	"title": "Nodiscard",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/outcome/",
	"title": "Outcome",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/payload/",
	"title": "Payload",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/policies/",
	"title": "Policies",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/result/",
	"title": "Result",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/terminate/",
	"title": "Terminate",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/try/",
	"title": "Try",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/unchecked/",
	"title": "Unchecked",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/undefined-behaviour/",
	"title": "Undefined Behaviour",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/value/",
	"title": "Value",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://ned14.github.io/outcome/tags/value-or-error/",
	"title": "Value or Error",
	"tags": [],
	"description": "",
	"content": ""
}]