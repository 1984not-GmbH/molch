# Boost-lite - Abstraction layer for the Boost C++ Libraries

(C) 2014-2016 Niall Douglas http://www.nedproductions.biz/

Linux: [![Build Status](https://travis-ci.org/ned14/boost-lite.svg?branch=master)](https://travis-ci.org/ned14/boost-lite) Windows: [![Build status](https://ci.appveyor.com/api/projects/status/y84ca5mdqwrstaw0?svg=true)](https://ci.appveyor.com/project/ned14/boost-apibind)

Herein is a set of tooling to enable a Boost library to swap in the C++ 11 standard library
instead of Boost, thus making it optionally independent of Boost. The following libraries
are swappable:

* [array](http://en.cppreference.com/w/cpp/header/atomic)
* [atomic](http://en.cppreference.com/w/cpp/header/atomic)
* [chrono](http://en.cppreference.com/w/cpp/header/chrono)
* [condition_variable](http://en.cppreference.com/w/cpp/header/condition_variable)
* [filesystem](http://en.cppreference.com/w/cpp/header/filesystem)
* [functional](http://en.cppreference.com/w/cpp/header/functional)
* [future](http://en.cppreference.com/w/cpp/header/future)
* [mutex](http://en.cppreference.com/w/cpp/header/mutex)
* [random](http://en.cppreference.com/w/cpp/header/random)
* [ratio](http://en.cppreference.com/w/cpp/header/ratio)
* [regex](http://en.cppreference.com/w/cpp/header/regex)
* [system_error](http://en.cppreference.com/w/cpp/header/system_error)
* [thread](http://en.cppreference.com/w/cpp/header/thread)
* [tuple](http://en.cppreference.com/w/cpp/header/tuple)
* [type_traits](http://en.cppreference.com/w/cpp/header/type_traits)
* [typeindex](http://en.cppreference.com/w/cpp/header/typeindex)

Note that only exactly interoperable binds are provided (excluding stuff not yet
supported by the clang AST parser extractor, currently namespaces, variables, some other stuff).

Usage might be like this:
```c++
#include "boost-lite/include/bind/stl11/boost/ratio"
#include "boost-lite/include/bind/stl11/std/ratio"
#include "boost-lite/include/boost/test/unit_test.hpp"
...
  // In this context use Boost's ratio
  {
    using namespace boost_lite::bind::boost::ratio;
    using two_thirds = ratio<2, 3>;
    using one_sixth = ratio<1, 6>;
    BOOST_CHECK((ratio_less<one_sixth, two_thirds>::value));
  }
  // In this context use STL11's ratio
  {
    using namespace boost_lite::bind::std::ratio;
    using two_thirds = ratio<2, 3>;
    using one_sixth = ratio<1, 6>;
    BOOST_CHECK((ratio_less<one_sixth, two_thirds>::value));
  }
```

Far more interesting is to have compile time macros select whether your Boost library uses Boost
or the C++ 11 standard library. This is how my libraries do this:
```c++
namespace boost { namespace afio { namespace stl11 {
#if BOOST_AFIO_USE_BOOST_THREAD
  using namespace boost_lite::bind::boost::thread;
#else
  using namespace boost_lite::bind::std::thread;
#endif
}}}
```
AFIO always refers to (boost|std)::thread stuff via stl11::thread. It "just works". See
[Boost.Outcome](https://github.com/ned14/boost.outcome),
[Boost.AFIO](https://github.com/ned14/boost.afio) or
[Boost.KernelTest](https://github.com/ned14/boost.kerneltest) for examples of practice.

You may find useful a clang AST based bindings generator which compares two namespaces and
extracts the interoperable definitions and which can be found in `build/genmap.cpp`. This is how
the bind files were generated by having the generator compare Boost and the STL headers
and extract the common definitions.

`include/import.hpp` has some preprocessor metaprogramming to help enforce unique namespacing
for some given configuration of your library. This allows differing configurations of your
Boost library to coexist in the same binary, and even the same translation unit! Usage might
be like this:

```c++
#include "boost-lite/include/import.h"

#if defined(BOOST_OUTCOME_LATEST_VERSION) && BOOST_OUTCOME_LATEST_VERSION < 1
# error You need to include the latest version of Boost.Outcome before any earlier versions within the same translation unit
#endif
#ifndef BOOST_OUTCOME_LATEST_VERSION
# define BOOST_OUTCOME_LATEST_VERSION 1
#endif

#if BOOST_OUTCOME_USE_BOOST_ERROR_CODE
# define BOOST_OUTCOME_V1_ERROR_CODE_IMPL boost
#else
# define BOOST_OUTCOME_V1_ERROR_CODE_IMPL std
#endif

#if BOOST_OUTCOME_LATEST_VERSION == 1
# define BOOST_OUTCOME_V1 (boost), (outcome), (BOOSTLITE_NAMESPACE_VERSION(v1, BOOST_OUTCOME_V1_ERROR_CODE_IMPL), inline)
#else
# define BOOST_OUTCOME_V1 (boost), (outcome), (BOOSTLITE_NAMESPACE_VERSION(v1, BOOST_OUTCOME_V1_ERROR_CODE_IMPL))
#endif
#define BOOST_OUTCOME_V1_NAMESPACE BOOSTLITE_NAMESPACE(BOOST_OUTCOME_V1)
#define BOOST_OUTCOME_V1_NAMESPACE_BEGIN BOOSTLITE_NAMESPACE_BEGIN(BOOST_OUTCOME_V1)
#define BOOST_OUTCOME_V1_NAMESPACE_END BOOSTLITE_NAMESPACE_END(BOOST_OUTCOME_V1)
```
A future edition of this library with come with cmake tooling which allows the `v1` to become
the last SHA of your git commit. This will effectively make any version of your library completely
independent of any other copy of your library, something extremely useful for header only libraries.

The usual Boost config macros like `BOOST_CONSTEXPR` are defined for you in
`include/boost/config.hpp`. A minimum emulation of Boost.Test is available in
`include/boost/test/unit_test.hpp` which uses a threadsafe edition of the CATCH C++ unit test
library.

Boost-lite is compatible with Boost - just make SURE you include Boost first in a translation
unit to avoid compiler warnings.

Other useful bits and pieces have snuck in over time:

* `include/allocator_testing.hpp`: A STL allocator configurable to fail to allocate in various
ways.
* `include/atuple.hpp`: A C++ 14 aggregate initialisable tuple standin for the C++ 17 tuple.
* `include/cpp_feature.h`: Makes consistent a set of C++ 17 feature test macros on any compiler.
* `include/execinfo_win64.h`: Implements `backtrace()` and `backtrace_symbols()` from glibc on
Windows.
* `include/ringbuffer_log.hpp`: Implements a very high performance fixed size threadsafe
ringbuffer logger with a STL container interface. Can take stack backtraces, log additional
data, indeed Boost.Outcome misuses it to retain extended error information when doing lossy
error state conversions.
* `include/spinlock.hpp`: A family of policy driven spinlocks which can substitute in for
a mutex.
* `include/tribool.hpp`: A constexpr three state boolean. Useful for ternary logic.
