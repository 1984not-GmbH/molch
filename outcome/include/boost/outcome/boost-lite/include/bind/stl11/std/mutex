/* This is an automatically generated bindings file. Don't modify it! */
#ifndef BOOSTLITE_BIND_STD_MUTEX_HPP
#define BOOSTLITE_BIND_STD_MUTEX_HPP

#include <mutex>
namespace boost_lite { namespace bind { namespace std { namespace mutex {
extern const char *boost_bindlib_in;
// begin call_once
#ifdef BOOST_STL11_MUTEX_MAP_NO_CALL_ONCE
#undef BOOST_STL11_MUTEX_MAP_NO_CALL_ONCE
#else
using ::std::call_once;
#endif
// end call_once
// begin try_lock
#ifdef BOOST_STL11_MUTEX_MAP_NO_TRY_LOCK
#undef BOOST_STL11_MUTEX_MAP_NO_TRY_LOCK
#else
using ::std::try_lock;
#endif
// end try_lock
// begin unique_lock
#ifdef BOOST_STL11_MUTEX_MAP_NO_UNIQUE_LOCK
#undef BOOST_STL11_MUTEX_MAP_NO_UNIQUE_LOCK
#else
template<class _Mutex> using unique_lock = ::std::unique_lock<_Mutex>;
#endif
// end unique_lock
// begin defer_lock_t
#ifdef BOOST_STL11_MUTEX_MAP_NO_DEFER_LOCK_T
#undef BOOST_STL11_MUTEX_MAP_NO_DEFER_LOCK_T
#else
using defer_lock_t = ::std::defer_lock_t;
#endif
// end defer_lock_t
// begin recursive_timed_mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_TIMED_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_TIMED_MUTEX
#else
using recursive_timed_mutex = ::std::recursive_timed_mutex;
#endif
// end recursive_timed_mutex
// begin timed_mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_TIMED_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_TIMED_MUTEX
#else
using timed_mutex = ::std::timed_mutex;
#endif
// end timed_mutex
// begin recursive_mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_MUTEX
#else
using recursive_mutex = ::std::recursive_mutex;
#endif
// end recursive_mutex
// begin lock_guard
#ifdef BOOST_STL11_MUTEX_MAP_NO_LOCK_GUARD
#undef BOOST_STL11_MUTEX_MAP_NO_LOCK_GUARD
#else
template<class _Mutex> using lock_guard = ::std::lock_guard<_Mutex>;
#endif
// end lock_guard
// begin mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_MUTEX
#else
using mutex = ::std::mutex;
#endif
// end mutex
// begin try_to_lock_t
#ifdef BOOST_STL11_MUTEX_MAP_NO_TRY_TO_LOCK_T
#undef BOOST_STL11_MUTEX_MAP_NO_TRY_TO_LOCK_T
#else
using try_to_lock_t = ::std::try_to_lock_t;
#endif
// end try_to_lock_t
// begin once_flag
#ifdef BOOST_STL11_MUTEX_MAP_NO_ONCE_FLAG
#undef BOOST_STL11_MUTEX_MAP_NO_ONCE_FLAG
#else
using once_flag = ::std::once_flag;
#endif
// end once_flag
// begin lock
#ifdef BOOST_STL11_MUTEX_MAP_NO_LOCK
#undef BOOST_STL11_MUTEX_MAP_NO_LOCK
#else
using ::std::lock;
#endif
// end lock
// begin adopt_lock_t
#ifdef BOOST_STL11_MUTEX_MAP_NO_ADOPT_LOCK_T
#undef BOOST_STL11_MUTEX_MAP_NO_ADOPT_LOCK_T
#else
using adopt_lock_t = ::std::adopt_lock_t;
#endif
// end adopt_lock_t
} } } } // namespace

#endif
