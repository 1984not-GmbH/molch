/* This is an automatically generated bindings file. Don't modify it! */
#ifndef BOOSTLITE_BIND_STD_FUTURE_HPP
#define BOOSTLITE_BIND_STD_FUTURE_HPP

#include <future>
namespace boost_lite { namespace bind { namespace std { namespace future {
extern const char *boost_bindlib_in;
// begin future_status
#ifdef BOOST_STL11_FUTURE_MAP_NO_FUTURE_STATUS
#undef BOOST_STL11_FUTURE_MAP_NO_FUTURE_STATUS
#else
using ::std::future_status;
#endif
// end future_status
// begin launch
#ifdef BOOST_STL11_FUTURE_MAP_NO_LAUNCH
#undef BOOST_STL11_FUTURE_MAP_NO_LAUNCH
#else
using ::std::launch;
#endif
// end launch
// begin future_errc
#ifdef BOOST_STL11_FUTURE_MAP_NO_FUTURE_ERRC
#undef BOOST_STL11_FUTURE_MAP_NO_FUTURE_ERRC
#else
using ::std::future_errc;
#endif
// end future_errc
// begin promise
#ifdef BOOST_STL11_FUTURE_MAP_NO_PROMISE
#undef BOOST_STL11_FUTURE_MAP_NO_PROMISE
#else
template<class _Res> using promise = ::std::promise<_Res>;
#endif
// end promise
// begin packaged_task
#ifdef BOOST_STL11_FUTURE_MAP_NO_PACKAGED_TASK
#undef BOOST_STL11_FUTURE_MAP_NO_PACKAGED_TASK
#else
template<class _Signature> using packaged_task = ::std::packaged_task<_Signature>;
#endif
// end packaged_task
// begin shared_future
#ifdef BOOST_STL11_FUTURE_MAP_NO_SHARED_FUTURE
#undef BOOST_STL11_FUTURE_MAP_NO_SHARED_FUTURE
#else
template<class _Res> using shared_future = ::std::shared_future<_Res>;
#endif
// end shared_future
// begin atomic_exchange
#ifdef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_EXCHANGE
#undef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_EXCHANGE
#else
using ::std::atomic_exchange;
#endif
// end atomic_exchange
// begin atomic_load
#ifdef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_LOAD
#undef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_LOAD
#else
using ::std::atomic_load;
#endif
// end atomic_load
// begin atomic_store
#ifdef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_STORE
#undef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_STORE
#else
using ::std::atomic_store;
#endif
// end atomic_store
// begin atomic_load_explicit
#ifdef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_LOAD_EXPLICIT
#undef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_LOAD_EXPLICIT
#else
using ::std::atomic_load_explicit;
#endif
// end atomic_load_explicit
// begin atomic_store_explicit
#ifdef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_STORE_EXPLICIT
#undef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_STORE_EXPLICIT
#else
using ::std::atomic_store_explicit;
#endif
// end atomic_store_explicit
// begin atomic_exchange_explicit
#ifdef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_EXCHANGE_EXPLICIT
#undef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_EXCHANGE_EXPLICIT
#else
using ::std::atomic_exchange_explicit;
#endif
// end atomic_exchange_explicit
// begin future_error
#ifdef BOOST_STL11_FUTURE_MAP_NO_FUTURE_ERROR
#undef BOOST_STL11_FUTURE_MAP_NO_FUTURE_ERROR
#else
using future_error = ::std::future_error;
#endif
// end future_error
// begin async
#ifdef BOOST_STL11_FUTURE_MAP_NO_ASYNC
#undef BOOST_STL11_FUTURE_MAP_NO_ASYNC
#else
using ::std::async;
#endif
// end async
// begin future_category
#ifdef BOOST_STL11_FUTURE_MAP_NO_FUTURE_CATEGORY
#undef BOOST_STL11_FUTURE_MAP_NO_FUTURE_CATEGORY
#else
using ::std::future_category;
#endif
// end future_category
// begin atomic_is_lock_free
#ifdef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_IS_LOCK_FREE
#undef BOOST_STL11_FUTURE_MAP_NO_ATOMIC_IS_LOCK_FREE
#else
using ::std::atomic_is_lock_free;
#endif
// end atomic_is_lock_free
// begin future
#ifdef BOOST_STL11_FUTURE_MAP_NO_FUTURE
#undef BOOST_STL11_FUTURE_MAP_NO_FUTURE
#else
template<class _Res> using future = ::std::future<_Res>;
#endif
// end future
} } } } // namespace

#endif
