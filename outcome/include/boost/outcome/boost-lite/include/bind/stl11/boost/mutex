/* This is an automatically generated bindings file. Don't modify it! */
#ifndef BOOSTLITE_BIND_BOOST_MUTEX_HPP
#define BOOSTLITE_BIND_BOOST_MUTEX_HPP

#include <boost/thread.hpp>
namespace boost_lite { namespace bind { namespace boost { namespace mutex {
extern const char *boost_bindlib_in;
// begin adopt_lock_t
#ifdef BOOST_STL11_MUTEX_MAP_NO_ADOPT_LOCK_T
#undef BOOST_STL11_MUTEX_MAP_NO_ADOPT_LOCK_T
#else
using adopt_lock_t = ::boost::adopt_lock_t;
#endif
// end adopt_lock_t
// begin defer_lock_t
#ifdef BOOST_STL11_MUTEX_MAP_NO_DEFER_LOCK_T
#undef BOOST_STL11_MUTEX_MAP_NO_DEFER_LOCK_T
#else
using defer_lock_t = ::boost::defer_lock_t;
#endif
// end defer_lock_t
// begin recursive_timed_mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_TIMED_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_TIMED_MUTEX
#else
using recursive_timed_mutex = ::boost::recursive_timed_mutex;
#endif
// end recursive_timed_mutex
// begin unique_lock
#ifdef BOOST_STL11_MUTEX_MAP_NO_UNIQUE_LOCK
#undef BOOST_STL11_MUTEX_MAP_NO_UNIQUE_LOCK
#else
template<class Mutex> using unique_lock = ::boost::unique_lock<Mutex>;
#endif
// end unique_lock
// begin lock_guard
#ifdef BOOST_STL11_MUTEX_MAP_NO_LOCK_GUARD
#undef BOOST_STL11_MUTEX_MAP_NO_LOCK_GUARD
#else
template<class Mutex> using lock_guard = ::boost::lock_guard<Mutex>;
#endif
// end lock_guard
// begin mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_MUTEX
#else
using mutex = ::boost::mutex;
#endif
// end mutex
// begin timed_mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_TIMED_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_TIMED_MUTEX
#else
using timed_mutex = ::boost::timed_mutex;
#endif
// end timed_mutex
// begin try_to_lock_t
#ifdef BOOST_STL11_MUTEX_MAP_NO_TRY_TO_LOCK_T
#undef BOOST_STL11_MUTEX_MAP_NO_TRY_TO_LOCK_T
#else
using try_to_lock_t = ::boost::try_to_lock_t;
#endif
// end try_to_lock_t
// begin recursive_mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_MUTEX
#else
using recursive_mutex = ::boost::recursive_mutex;
#endif
// end recursive_mutex
// begin call_once
#ifdef BOOST_STL11_MUTEX_MAP_NO_CALL_ONCE
#undef BOOST_STL11_MUTEX_MAP_NO_CALL_ONCE
#else
using ::boost::call_once;
#endif
// end call_once
// begin once_flag
#ifdef BOOST_STL11_MUTEX_MAP_NO_ONCE_FLAG
#undef BOOST_STL11_MUTEX_MAP_NO_ONCE_FLAG
#else
using once_flag = ::boost::once_flag;
#endif
// end once_flag
// begin lock
#ifdef BOOST_STL11_MUTEX_MAP_NO_LOCK
#undef BOOST_STL11_MUTEX_MAP_NO_LOCK
#else
using ::boost::lock;
#endif
// end lock
// begin try_lock
#ifdef BOOST_STL11_MUTEX_MAP_NO_TRY_LOCK
#undef BOOST_STL11_MUTEX_MAP_NO_TRY_LOCK
#else
using ::boost::try_lock;
#endif
// end try_lock
} } } } // namespace

#endif
